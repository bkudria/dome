import processing.core.*; 
import processing.data.*; 
import processing.event.*; 
import processing.opengl.*; 

import wblut.math.*; 
import wblut.processing.*; 
import wblut.core.*; 
import wblut.hemesh.*; 
import wblut.geom.*; 
import heronarts.lx.*; 
import heronarts.lx.audio.*; 
import heronarts.lx.color.*; 
import heronarts.lx.effect.*; 
import heronarts.lx.model.*; 
import heronarts.lx.modulator.*; 
import heronarts.lx.output.*; 
import heronarts.lx.parameter.*; 
import heronarts.lx.pattern.*; 
import heronarts.lx.transition.*; 
import heronarts.p2lx.*; 
import heronarts.p2lx.ui.*; 
import heronarts.p2lx.ui.control.*; 
import heronarts.p2lx.ui.component.*; 
import ddf.minim.*; 
import processing.opengl.*; 
import java.util.Arrays; 
import java.util.List; 
import java.util.Collections; 
import java.util.ArrayList; 
import java.util.LinkedList; 
import java.util.Iterator; 
import java.util.Random; 
import java.util.Collections; 
import java.awt.Dimension; 
import java.awt.Toolkit; 

import heronarts.lx.color.*; 
import com.vividsolutions.jts.shape.*; 
import heronarts.p2lx.ui.*; 
import heronarts.lx.effect.*; 
import artnetP5.*; 
import wblut.math.*; 
import heronarts.lx.model.*; 
import javolution.xml.internal.*; 
import gnu.trove.*; 
import com.vividsolutions.jts.operation.valid.*; 
import com.vividsolutions.jts.operation.buffer.*; 
import wblut.processing.*; 
import com.vividsolutions.jts.shape.fractal.*; 
import com.vividsolutions.jts.algorithm.match.*; 
import heronarts.p2lx.ui.component.*; 
import javolution.io.*; 
import gnu.trove.iterator.*; 
import javolution.lang.*; 
import com.vividsolutions.jts.algorithm.distance.*; 
import com.vividsolutions.jts.operation.predicate.*; 
import com.vividsolutions.jts.densify.*; 
import com.vividsolutions.jts.geom.impl.*; 
import gnu.trove.procedure.*; 
import com.vividsolutions.jts.index.quadtree.*; 
import javolution.util.function.*; 
import javolution.context.internal.*; 
import javolution.util.service.*; 
import com.vividsolutions.jts.util.*; 
import com.vividsolutions.jts.geomgraph.*; 
import javolution.util.internal.bitset.*; 
import artnet4j.*; 
import com.vividsolutions.jts.precision.*; 
import gnu.trove.list.array.*; 
import gnu.trove.strategy.*; 
import javolution.xml.sax.*; 
import javolution.osgi.internal.*; 
import gnu.trove.queue.*; 
import com.vividsolutions.jts.index.chain.*; 
import javolution.util.internal.table.*; 
import heronarts.lx.transform.*; 
import gnu.trove.procedure.array.*; 
import com.vividsolutions.jts.planargraph.algorithm.*; 
import com.vividsolutions.jts.geom.*; 
import com.vividsolutions.jts.io.*; 
import heronarts.p2lx.ui.control.*; 
import heronarts.lx.*; 
import com.vividsolutions.jts.geom.util.*; 
import com.vividsolutions.jts.index.strtree.*; 
import gnu.trove.list.*; 
import heronarts.lx.pattern.*; 
import com.vividsolutions.jts.operation.buffer.validate.*; 
import javolution.util.internal.comparator.*; 
import javolution.context.*; 
import javolution.util.internal.*; 
import com.vividsolutions.jts.shape.random.*; 
import javolution.xml.internal.stream.*; 
import com.vividsolutions.jts.index.bintree.*; 
import com.vividsolutions.jts.operation.linemerge.*; 
import javolution.tools.*; 
import javolution.xml.ws.*; 
import gnu.trove.decorator.*; 
import wblut.geom.*; 
import com.vividsolutions.jts.operation.distance3d.*; 
import javolution.text.*; 
import wblut.hemesh.*; 
import com.vividsolutions.jts.index.kdtree.*; 
import com.vividsolutions.jts.operation.relate.*; 
import heronarts.p2lx.video.*; 
import javolution.xml.*; 
import javolution.xml.stream.*; 
import javolution.util.*; 
import gnu.trove.impl.hash.*; 
import heronarts.p2lx.font.*; 
import gnu.trove.map.*; 
import com.vividsolutions.jts.simplify.*; 
import heronarts.lx.parameter.*; 
import javolution.util.internal.set.sorted.*; 
import javolution.text.internal.*; 
import com.vividsolutions.jts.noding.snapround.*; 
import com.vividsolutions.jts.geomgraph.index.*; 
import com.vividsolutions.jts.index.sweepline.*; 
import com.vividsolutions.jts.index.*; 
import javolution.util.internal.map.sorted.*; 
import gnu.trove.set.hash.*; 
import javolution.util.internal.table.sorted.*; 
import artnet4j.events.*; 
import wblut.core.*; 
import gnu.trove.function.*; 
import com.vividsolutions.jts.operation.union.*; 
import wblut.external.straightskeleton.*; 
import heronarts.lx.transition.*; 
import com.vividsolutions.jts.operation.overlay.*; 
import com.vividsolutions.jts.io.gml2.*; 
import gnu.trove.impl.unmodifiable.*; 
import gnu.trove.map.custom_hash.*; 
import gnu.trove.set.*; 
import com.vividsolutions.jts.*; 
import gnu.trove.stack.array.*; 
import com.vividsolutions.jts.noding.*; 
import gnu.trove.impl.*; 
import javolution.util.internal.map.*; 
import com.vividsolutions.jts.linearref.*; 
import com.vividsolutions.jts.awt.*; 
import com.vividsolutions.jts.algorithm.*; 
import heronarts.lx.audio.*; 
import heronarts.lx.midi.*; 
import artnet4j.packets.*; 
import com.vividsolutions.jts.operation.*; 
import com.vividsolutions.jts.operation.distance.*; 
import com.vividsolutions.jts.index.intervalrtree.*; 
import com.vividsolutions.jts.triangulate.*; 
import heronarts.lx.modulator.*; 
import com.vividsolutions.jts.planargraph.*; 
import heronarts.lx.output.*; 
import gnu.trove.list.linked.*; 
import javax.realtime.*; 
import org.osgi.service.log.*; 
import gnu.trove.iterator.hash.*; 
import javolution.util.internal.set.*; 
import com.vividsolutions.jts.math.*; 
import com.vividsolutions.jts.operation.overlay.snap.*; 
import heronarts.p2lx.*; 
import com.vividsolutions.jts.operation.polygonize.*; 
import wblut.external.ProGAL.*; 
import com.vividsolutions.jts.algorithm.locate.*; 
import wblut.external.QuickHull3D.*; 
import gnu.trove.impl.sync.*; 
import javolution.util.internal.collection.*; 
import com.vividsolutions.jts.triangulate.quadedge.*; 
import gnu.trove.stack.*; 
import gnu.trove.map.hash.*; 
import com.vividsolutions.jts.geom.prep.*; 
import com.vividsolutions.jts.operation.overlay.validate.*; 
import wblut.external.JAMA.*; 
import heronarts.lx.midi.device.*; 

import java.util.HashMap; 
import java.util.ArrayList; 
import java.io.File; 
import java.io.BufferedReader; 
import java.io.PrintWriter; 
import java.io.InputStream; 
import java.io.OutputStream; 
import java.io.IOException; 

public class dome extends PApplet {

/**
 *  Importing a bunch of stuff.
 *  Artists, keep scrolling to  add your patterns.
 */





























/** 
 * This is the code to be thrown at LEDome! 
 * 
 * This Processing sketch is a fun place to build animations, effects, and 
 * interactions for the LEDome. Most of the ugly modeling and mapping code 
 * is contained in the LEDome class and setup files.
 * artist, you shouldn't need to worry about any of that.
 *
 * Below, you will find definitions of the Patterns, (and eventually) Effects, 
 * and Interactions.
 *
 * If you're an artist, create a new tab in the Processing environment with
 * your name. Implement your classes there, and add them to the list below.
 */ 

public LXPattern[] patterns(P2LX lx) {
  return new LXPattern[] {
    // L8on
    new Snakes(lx),
    new Explosions(lx),  
    new SpotLights(lx),
    new Life(lx),
    new L8onMixColor(lx),
    
    // Create New Pattern Instances Below HERE
    // BKudria
    new Beachball(lx),

    // Kristj\u00e1n
    new Disco(lx),

    // pld
    new Spiral(lx),

    // Test Patterns
    new LayerDemoPattern(lx),
    new FaceIteratorTest(lx),
    new EdgeIteratorTest(lx),
    new HueTestPattern(lx),
    new IteratorTestPattern(lx).setTransition(new DissolveTransition(lx))
  };
}

public LXEffect[] effects(P2LX lx) {
  return new LXEffect[] {    
    new ExplosionEffect(lx),
    new FlashEffect(lx),
    new DesaturationEffect(lx), 
    new BlurEffect(lx)
  };
}
class Beachball extends LXPattern {
  private final int stripeSize = 360 / 10;
  private final int maxTwist   = 24;
  private final int spinRate   = 2600;

  private final SawLFO angle   = new SawLFO(0, 360, spinRate);

  public String getName() { return "Beachball"; }
  public Beachball(P2LX lx) {
    super(lx);
    addModulator(angle).start();
    drawBeachball();
  }

  public void run(double deltaMs) {
    drawBeachball();
  }

  public void drawBeachball() {
    for (LXPoint p : model.points) {
      float dist       = dist(model.cx, model.cz, p.x, p.z);
      float radius     = map(dist, 0, LEDome.DOME_RADIUS, 0, 1);

      float twistAngle = LXUtils.lerpf(0.0f, maxTwist, radius);
      float pixelAngle     = (p.ztheta * (180.0f/PI));
      float sweepingAngle  = pixelAngle + twistAngle - angle.getValuef();

      double stripe = floor( (sweepingAngle % 360) / stripeSize);

      double hue        = (pixelAngle) % 360;
      double saturation = (stripe % 2 == 0) ? 75  : 100;
      double brightness = (stripe % 2 == 0) ? 100 : 75;

      colors[p.index] = LXColor.hsb(hue, saturation, brightness);
    }
  }
}


class Disco extends LXPattern {
  public static final int SET_COUNT = 3;
  public static final float HUE_SEPARATION = 360 / SET_COUNT;

  private LEDome dome;

  private List<LEDomeFace> litFaces;
  private List<List<LEDomeFace>> faceSets ;

  private Random random = new Random();

  public BasicParameter tempo = new BasicParameter("TPO", 500, 250, 3000);
  private SawLFO beat = new SawLFO(0.0f, 1.0f, tempo);

  public String getName() { return "Disco"; }

  public Disco(LX lx) {
    super(lx);
    addParameter(tempo);
    addModulator(beat).start();
    this.dome = (LEDome) model;
    this.litFaces = litFaces();

    this.faceSets = new ArrayList<List<LEDomeFace>>();
    for (int i = 0; i < SET_COUNT; i++) {
      this.faceSets.add(new ArrayList<LEDomeFace>());
    }
    shuffleFaces();
  }

  public void run(double deltaMs) {
    if (beat.getValue() > .95f) shuffleFaces();
    for (int i = 0; i < SET_COUNT; i++) {
      for (LEDomeFace face : this.faceSets.get(i)) {
        for (LXPoint p : face.points) {
          colors[p.index] = LXColor.hsb(HUE_SEPARATION * i + HUE_SEPARATION / 2, 100, 100 * (1 - beat.getValue()));
        }
      }
    }
  }

  private List<LEDomeFace> litFaces() {
    List<LEDomeFace> faces = new ArrayList<LEDomeFace>();
    for (LEDomeFace face : this.dome.getFaces()) {
      if (face.hasLights()) faces.add(face);
    }
    return faces;
  }

  private LEDomeFace randomLitFace() {
    return this.litFaces.get(random.nextInt(this.litFaces.size()));
  }

  private void shuffleFaces() {
    for (int i = 0; i < this.faceSets.size(); i++) this.faceSets.get(i).clear();
    Collections.shuffle(this.litFaces);
    for (int i = 0; i < this.litFaces.size(); i++) {
      this.faceSets.get(i % SET_COUNT).add(this.litFaces.get(i));
    }
  }
}
class Snakes extends LXPattern {
  // Used to store info about each explosion.
  // See L8onUtil.pde for the definition.
  private List<SnakeLayer> snakes = new ArrayList<SnakeLayer>();
  private BasicParameter numSnakes = new BasicParameter("NUM", 2.0f, 1.0f, 30.0f);  
  private BasicParameter snakeSpeed = new BasicParameter("SPD", 64.0f, 6.0f, 480.0f);
  private BasicParameter brightnessParameter = new BasicParameter("BRGT", 60.0f, 10.0f, 80.0f);
  private BasicParameter lengthParameter = new BasicParameter("LNGT", 8.0f, 3.0f, 48.0f);  
  
  public Snakes(LX lx) {
    this(lx, 0.0f);
  }
  
  public String getName() { return "Snakes"; }

  public Snakes(LX lx, float hueDelta) {
    super(lx);

    addParameter(numSnakes);
    addParameter(snakeSpeed);
    addParameter(brightnessParameter);
    addParameter(lengthParameter);

    initSnakes();
  }

  public void run(double deltaMs) {
    calibrateSnakes();
    
    float hueStep = 0;   
    for(SnakeLayer snake: this.snakes) {
      snake.hue = LXUtils.wrapdistf(lx.getBaseHuef(), lx.getBaseHuef() + hueStep, 360);
      hueStep += 360.0f / (float)this.snakes.size();
    }
    
    for (LXPoint p : model.points) {
      int numSnakes = 0;
      
      for(SnakeLayer snake: this.snakes) {
        if (!snake.hasPoint(p)) { continue; }
        
        numSnakes++;
        
        if (numSnakes == 1) {
          colors[p.index] = snake.colorOf(p.index);        
        } else {
          colors[p.index] = this.blendSnakes(colors[p.index], snake.colorOf(p.index), numSnakes);
        }
        
      }
      
      if (numSnakes == 0) {        
        colors[p.index] = LX.hsb(LXColor.h(colors[p.index]), LXColor.s(colors[p.index]), 0.0f);
      }
    }
  }
  
  public int blendSnakes(int startColor, int nextColor, int numSnakes) {
    if (numSnakes == 1) { return nextColor; }
        
    float h, s, b, minHue, maxHue;
    float startHue = LXColor.h(startColor);
            
    minHue = min(startHue, LXColor.h(nextColor));
    maxHue = max(startHue, LXColor.h(nextColor));
    h = (minHue * 2.0f + maxHue / 2.0f) / 2.0f;
    s = (LXColor.s(startColor) + LXColor.s(nextColor)) / 2.0f;
    b = (LXColor.b(startColor) + LXColor.b(nextColor)) / 2.0f;
    
    return LXColor.hsb(h, s, b);
  }

  public void initSnakes() {
    snakes.clear();
    
    for(int i = 0; i < (int)this.numSnakes.getValuef(); i++) {
      SnakeLayer snake = new SnakeLayer(lx, lengthParameter, snakeSpeed, brightnessParameter);
      snakes.add(snake);
      addLayer(snake);
    }
  }
  
  public void calibrateSnakes() {
    if ((int)this.numSnakes.getValue() == this.snakes.size()) { return; }
  
    if ((int)this.numSnakes.getValue() < this.snakes.size()) {
      for(int i = (this.snakes.size() - 1); i >= (int)this.numSnakes.getValue(); i--) {
        this.snakes.remove(i);
      }
    } else {
      for(int i = 0; i < ((int)this.numSnakes.getValuef() - this.snakes.size()); i++) {
        SnakeLayer snake = new SnakeLayer(lx, lengthParameter, snakeSpeed, brightnessParameter);
        snakes.add(snake);
        addLayer(snake);
      }
    }
  }
}

class Explosions extends LXPattern {
  // Used to store info about each explosion.
  // See L8onUtil.pde for the definition.
  private List<L8onExplosion> explosions = new ArrayList<L8onExplosion>();
  private final SinLFO saturationModulator = new SinLFO(70.0f, 90.0f, 20 * SECONDS);
  private BasicParameter numExplosionsParameter = new BasicParameter("NUM", 2.0f, 1.0f, 30.0f);
  private BasicParameter brightnessParameter = new BasicParameter("BRGT", 50, 10, 80);

  private BasicParameter rateParameter = new BasicParameter("RATE", 4000.0f, 500.0f, 20000.0f);
  private BasicParameter blurParameter = new BasicParameter("BLUR", 0.69f);

  private BlurLayer blurLayer = new BlurLayer(lx, this, blurParameter);

  public Explosions(LX lx) {
    super(lx);

    addParameter(numExplosionsParameter);
    addParameter(brightnessParameter);

    addParameter(rateParameter);
    addParameter(blurParameter);

    addLayer(blurLayer);

    addModulator(saturationModulator).start();

    initExplosions();
  }

  public void run(double deltaMs) {
    initExplosions();

    float base_hue = lx.getBaseHuef();
    float wave_hue_diff = (float) (360.0f / this.explosions.size());

    for(L8onExplosion explosion : this.explosions) {
      if (explosion.isChillin((float)deltaMs)) {
        continue;
      }
 
      explosion.hue_value = (float)(base_hue % 360.0f);
      base_hue += wave_hue_diff;

      if (!explosion.hasExploded()) {
        explosion.explode();
      } else if (explosion.isFinished()) {
        assignNewCenter(explosion);
      }
    }

    int c;
    float hue_value = 0.0f;
    float sat_value = saturationModulator.getValuef();
    float brightness_value = brightnessParameter.getValuef();
    float min_hv;
    float max_hv;

    for (LXPoint p : model.points) {
      int num_explosions_in = 0;

      for(L8onExplosion explosion : this.explosions) {
        if(explosion.isChillin(0)) {
          continue;
        }

        if(explosion.onExplosion(p.x, p.y, p.z)) {
          num_explosions_in++;

          if(num_explosions_in == 1) {
            hue_value = explosion.hue_value;
          } if(num_explosions_in == 2) {
            // Blend new color with previous color.
            min_hv = min(hue_value, explosion.hue_value);
            max_hv = max(hue_value, explosion.hue_value);
            hue_value = (min_hv * 2.0f + max_hv / 2.0f) / 2.0f;
          } else {
            // Jump color by 180 before blending again.
            hue_value = LXUtils.wrapdistf(0, hue_value + 180, 360);
            min_hv = min(hue_value, explosion.hue_value);
            max_hv = max(hue_value, explosion.hue_value);
            hue_value = (min_hv * 2.0f + max_hv / 2.0f) / 2.0f;
          }
        }
      }

      if(num_explosions_in > 0) {
        c = LX.hsb(hue_value, sat_value, brightness_value);
      } else {
        c = colors[p.index];
        c = LX.hsb(LXColor.h(c), LXColor.s(c), 0.0f);
      }

      colors[p.index] = c;
    }
  }

  private void initExplosions() {
    int num_explosions = (int) numExplosionsParameter.getValue();

    if (this.explosions.size() == num_explosions) {
      return;
    }

    if (this.explosions.size() < num_explosions) {
      for(int i = 0; i < (num_explosions - this.explosions.size()); i++) {
        float stroke_width = this.new_stroke_width();
        QuadraticEnvelope new_radius_env = new QuadraticEnvelope(0.0f, model.xRange, rateParameter);
        new_radius_env.setEase(QuadraticEnvelope.Ease.OUT);
        WB_Point new_center = ((LEDome)model).randomFaceCenter();
        addModulator(new_radius_env);
        this.explosions.add(
          new L8onExplosion(new_radius_env, stroke_width, new_center.xf(), new_center.yf(), new_center.zf())
        );
      }
    } else {
      for(int i = (this.explosions.size() - 1); i >= num_explosions; i--) {
        this.explosions.remove(i);
      }
    }
  }

  private void assignNewCenter(L8onExplosion explosion) {
    float stroke_width = this.new_stroke_width();
    WB_Point new_center = ((LEDome)model).randomFaceCenter();
    float chill_time = (3.0f + random(7)) * SECONDS;
    QuadraticEnvelope new_radius_env = new QuadraticEnvelope(0.0f, model.xRange, rateParameter);
    new_radius_env.setEase(QuadraticEnvelope.Ease.OUT);

    explosion.setCenter(new_center.xf(), new_center.yf(), new_center.zf());
    addModulator(new_radius_env);
    explosion.setRadiusModulator(new_radius_env, stroke_width);
    explosion.setChillTime(chill_time);
  }

  public float new_stroke_width() {
    return 3 * INCHES + random(6 * INCHES);
  }
}

class SpotLights extends LXPattern {
  // Used to store info about each spotlight.
  // See L8onUtil.pde for the definition.
  private List<L8onSpotLight> spotlights = new ArrayList<L8onSpotLight>();

  private final SinLFO saturationModulator = new SinLFO(75.0f, 95.0f, 20 * SECONDS);

  // Controls the radius of the spotlights.
  private BasicParameter radiusParameter = new BasicParameter("RAD", 2.5f * FEET, 1.0f, model.xRange / 2.0f);
  private BasicParameter numLightsParameter = new BasicParameter("NUM", 3.0f, 1.0f, 30.0f);
  private BasicParameter brightnessParameter = new BasicParameter("BRGT", 50, 10, 80);

  private BasicParameter rateParameter = new BasicParameter("RATE", 4000.0f, 1.0f, 10000.0f);
  private BasicParameter restParameter = new BasicParameter("REST", 900.0f, 1.0f, 10000.0f);
  private BasicParameter delayParameter = new BasicParameter("DELAY", 0, 0.0f, 2000.0f);
  private BasicParameter minDistParameter = new BasicParameter("DIST", 100.0f, 10.0f, model.xRange);
  
  private BasicParameter blurParameter = new BasicParameter("BLUR", 0.69f);

  private BlurLayer blurLayer = new BlurLayer(lx, this, blurParameter);

  public SpotLights(P2LX lx) {
    super(lx);

    addParameter(radiusParameter);
    addParameter(numLightsParameter);
    addParameter(brightnessParameter);

    addParameter(rateParameter);
    addParameter(restParameter);
    addParameter(delayParameter);
    addParameter(minDistParameter);
    addParameter(blurParameter);

    addLayer(blurLayer);

    addModulator(saturationModulator).start();

    initL8onSpotlights();
  }

  public void run(double deltaMs) {
    initL8onSpotlights();
    float spotlight_radius = radiusParameter.getValuef();
    float base_hue = lx.getBaseHuef();
    float wave_hue_diff = (float) (360.0f / this.spotlights.size());
    float dist_from_dest;

    for(L8onSpotLight spotlight : this.spotlights) {
      spotlight.hue_value = base_hue;
      base_hue += wave_hue_diff;
      dist_from_dest = spotlight.distFromDestination();

      if (dist_from_dest < 0.01f) {
        if(spotlight.time_at_dest_ms > restParameter.getValuef()) {
          // Will set a new destination if first guess is greater than min distance.
          // Otherwise, will keep object as is and try again next tick.
          spotlight.tryNewDestination();
        } else {
          spotlight.addTimeAtDestination((float)deltaMs);
        }
      } else {
        float dist_to_travel = rateParameter.getValuef() / ((float)deltaMs * 100);
        float dist_to_travel_perc = min(dist_to_travel / dist_from_dest, 1.0f);

        spotlight.movePercentageTowardDestination(dist_to_travel_perc);
      }
    }

    int c;
    float hue_value = 0.0f;
    float sat_value = saturationModulator.getValuef();
    float brightness_value = brightnessParameter.getValuef();
    float min_hv;
    float max_hv;

    for (LXPoint p : model.points) {
      int num_spotlights_in = 0;

      for(L8onSpotLight spotlight : this.spotlights) {
        float dist_from_spotlight = dist(spotlight.center_x, spotlight.center_y, spotlight.center_z, p.x, p.y, p.z);

        if(dist_from_spotlight <= spotlight_radius) {
          num_spotlights_in++;

          if(num_spotlights_in == 1) {
            hue_value = spotlight.hue_value;
          } if(num_spotlights_in == 2) {
            // Blend new color with previous color.
            min_hv = min(hue_value, spotlight.hue_value);
            max_hv = max(hue_value, spotlight.hue_value);
            hue_value = (min_hv * 2.0f + max_hv / 2.0f) / 2.0f;
          } else {
            // Jump color by 180 before blending again.
            hue_value = LXUtils.wrapdistf(0, hue_value + 180, 360);
            min_hv = min(hue_value, spotlight.hue_value);
            max_hv = max(hue_value, spotlight.hue_value);
            hue_value = (min_hv * 2.0f + max_hv / 2.0f) / 2.0f;
          }
        }
      }

      if(num_spotlights_in > 0) {
        c = LX.hsb(hue_value, sat_value, brightness_value);
      } else {
        c = colors[p.index];
        c = LX.hsb(LXColor.h(c), LXColor.s(c), L8onUtil.decayed_brightness(c, delayParameter.getValuef(), deltaMs));
      }

      colors[p.index] = c;
    }
  }

  /**
   * Initialize the waves.
   */
  private void initL8onSpotlights() {
    int num_spotlights = (int) numLightsParameter.getValue();
    if (this.spotlights.size() == num_spotlights) {
      return;
    }

    if (this.spotlights.size() < num_spotlights) {
      float min_dist = minDistParameter.getValuef();

      for(int i = 0; i < (num_spotlights - this.spotlights.size()); i++) {
        this.spotlights.add(
          new L8onSpotLight(((LEDome)model).sphere,
                            model.xMin + random(model.xRange), model.yMin + random(model.yRange), model.zMin + random(model.zRange),
                            model.yMin + random(model.yRange), model.yMin + random(model.yRange), model.zMin + random(model.zRange),
                            min_dist)
        );
      }
    } else {
      for(int i = (this.spotlights.size() - 1); i >= num_spotlights; i--) {
        this.spotlights.remove(i);
      }
    }
  }
}

/**
 * 2 slanted breathing waves with bands of color.
 *
 * Each wave is a specific color, their intersection is the mix of those two colors.
 * Between each wave, there are a discrete number of bands of color.
 */
class L8onMixColor extends LXPattern {
  // Oscillators for the wave breathing effect.
  private final SinLFO xOffsetMax = new SinLFO( -1 * (model.xRange / 2.0f) , model.xRange / 2.0f, 20000);
  private final SinLFO yOffsetMax = new SinLFO( -1 * (model.yRange / 2.0f) , model.yRange / 2.0f, 20000);
  private final SinLFO zOffsetMax = new SinLFO( -1 * (model.zRange / 2.0f) , model.zRange / 2.0f, 20000);

  // Used to store info about each wave.
  // See L8onUtil.pde for the definition.
  private List<L8onWave> l8on_waves;

  // Controls the radius of the string.
  private BasicParameter radiusParameterX = new BasicParameter("RADX", 1 * FEET, 1.0f, model.xRange / 2.0f);
  private BasicParameter radiusParameterY = new BasicParameter("RADY", 1 * FEET, 1.0f, model.yRange / 2.0f);
  private BasicParameter radiusParameterZ = new BasicParameter("RADZ", 1 * FEET, 1.0f, model.yRange / 2.0f);
  // Controls the center X coordinate of the waves.
  private BasicParameter centerXParameter = new BasicParameter("X", (model.xMin + model.xMax) / 2.0f, model.xMin, model.xMax);
    // Controles the center Y coordinate of the waves.
  private BasicParameter centerYParameter = new BasicParameter("Y", (model.yMin + model.yMax) / 2.0f, model.yMin, model.yMax);
  // Controls the center Z coordinate of the waves.
  private BasicParameter centerZParameter = new BasicParameter("Z", (model.zMin + model.zMax) / 2.0f, model.zMin, model.zMax);
  // Controls the number of waves by axis.
  private BasicParameter numWavesX = new BasicParameter("WAVX", 3.0f, 1.0f, 10.0f);
  private BasicParameter numWavesY = new BasicParameter("WAVY", 4.0f, 1.0f, 10.0f);
  private BasicParameter numWavesZ = new BasicParameter("WAVZ", 4.0f, 1.0f, 10.0f);
  // Controls brightness of on lights
  private BasicParameter brightnessParameter = new BasicParameter("BRGT", 50, 10, 80);
  private BasicParameter saturationParameter = new BasicParameter("SAT", 65, 0, 100);
  // Controls the the amount of delay until a light is completely off.
  private BasicParameter delayParameter = new BasicParameter("DELAY", 500, 0.0f, 2000.0f);

  public L8onMixColor(P2LX lx) {
    super(lx);

    initL8onWaves();

    addParameter(radiusParameterX);
    addParameter(radiusParameterY);
    addParameter(radiusParameterZ);
    addParameter(numWavesX);
    addParameter(numWavesY);
    addParameter(numWavesZ);
    addParameter(centerXParameter);
    addParameter(centerYParameter);
    addParameter(centerZParameter);
    addParameter(brightnessParameter);
    addParameter(saturationParameter);
    addParameter(delayParameter);

    addModulator(xOffsetMax).trigger();
    addModulator(yOffsetMax).trigger();
    addModulator(zOffsetMax).trigger();
  }

  public void run(double deltaMs) {
    float offset_value_x = xOffsetMax.getValuef();
    float offset_value_z = zOffsetMax.getValuef();
    float base_hue = lx.getBaseHuef();
    float wave_hue_diff = (float) (360.0f / this.l8on_waves.size());

    for(L8onWave l8on_wave : this.l8on_waves) {
      l8on_wave.hue_value = base_hue;
      base_hue += wave_hue_diff;
    }

    int c;
//    float dist_percentage;
    float hue_value = 0.0f;
    float sat_value = saturationParameter.getValuef();
    float brightness_value = brightnessParameter.getValuef();
    float wave_center_x;
    float wave_center_y;
    float wave_center_z;
    float wave_radius;
    float min_hv;
    float max_hv;

    for (LXPoint p : model.points) {
      float x_percentage = (p.x - model.xMin) / model.xRange;
      float y_percentage = (p.y - model.yMin) / model.yRange;
      float z_percentage = (p.z - model.zMin) / model.zRange;
//      float sin_x = sin(PI / 2 + numWavesX.getValuef() * PI * x_percentage);
      float cos_x = cos(PI / 2 + numWavesX.getValuef() * PI * x_percentage);
      float sin_y = sin(PI / 2 + numWavesY.getValuef() * PI * y_percentage);
//      float cos_y = cos(PI / 2 + numWavesY.getValuef() * PI * y_percentage);
      float sin_z = sin(PI / 2 + numWavesZ.getValuef() * PI * z_percentage);
//      float cos_z = cos(PI / 2 + numWavesZ.getValuef() * PI * z_percentage);

      int num_waves_in = 0;

      for(L8onWave l8on_wave : this.l8on_waves) {
        wave_center_x = p.x;
        wave_center_y = p.y;
        wave_center_z = p.z;

        if(l8on_wave.direction == L8onWave.DIRECTION_X) {
          wave_center_z = centerZParameter.getValuef() + (l8on_wave.offset_multiplier * offset_value_z * cos_x);
          wave_radius = radiusParameterX.getValuef();
        } else if(l8on_wave.direction == L8onWave.DIRECTION_Y) {
          wave_center_x = centerXParameter.getValuef() + (l8on_wave.offset_multiplier * offset_value_x * sin_y);
          wave_radius = radiusParameterX.getValuef();
        } else {
          wave_center_x = centerXParameter.getValuef() + (l8on_wave.offset_multiplier * offset_value_x * sin_z);
          wave_radius = radiusParameterZ.getValuef();
        }

        float dist_from_wave = distance_from_wave(p, wave_center_x, wave_center_y, wave_center_z);

        if(dist_from_wave <= wave_radius) {
          num_waves_in++;

          if(num_waves_in == 1) {
            hue_value = l8on_wave.hue_value;
          } if(num_waves_in == 2) {
            // Blend new color with previous color.
            min_hv = min(hue_value, l8on_wave.hue_value);
            max_hv = max(hue_value, l8on_wave.hue_value);
            hue_value = (min_hv * 2.0f + max_hv / 2.0f) / 2.0f;
          } else {
            // Jump color by 180 before blending again.
            hue_value = LXUtils.wrapdistf(0, hue_value + 180, 360);
            min_hv = min(hue_value, l8on_wave.hue_value);
            max_hv = max(hue_value, l8on_wave.hue_value);
            hue_value = (min_hv * 2.0f + max_hv / 2.0f) / 2.0f;
          }
        }
      }

      if(num_waves_in > 0) {
        c = LX.hsb(hue_value, sat_value, brightness_value);
      } else {
        c = colors[p.index];
        c = LX.hsb(LXColor.h(c), LXColor.s(c), L8onUtil.decayed_brightness(c, delayParameter.getValuef(), deltaMs));
      }

      colors[p.index] = c;
    }
  }

  /**
   * Calculates the distance between a point the center of the wave with the given coordinates.
   */
  public float distance_from_wave(LXPoint p, float wave_center_x, float wave_center_y, float wave_center_z) {
    return dist(p.x, p.y, p.z, wave_center_x, wave_center_y, wave_center_z);
  }

  /**
   * Initialize the waves.
   */
  private void initL8onWaves() {
    this.l8on_waves = new LinkedList<L8onWave>();

    this.l8on_waves.add( new L8onWave(L8onWave.DIRECTION_X, 1.0f) );
    this.l8on_waves.add( new L8onWave(L8onWave.DIRECTION_Y, 1.0f) );
    this.l8on_waves.add( new L8onWave(L8onWave.DIRECTION_Z, 1.0f) );
    this.l8on_waves.add( new L8onWave(L8onWave.DIRECTION_X, -1.0f) );
    this.l8on_waves.add( new L8onWave(L8onWave.DIRECTION_Y, -1.0f) );
    this.l8on_waves.add( new L8onWave(L8onWave.DIRECTION_Z, -1.0f) );
  }
}

/**
 * A "Game of Life" simulation in 2 dimensions with the cubes as cells.
 *
 * The "DELAY parameter controls the rate of change.
 * The "MUT" parameter controls the probability of mutations. Useful when life oscillates between few states.
 * The "SAT" parameter controls the saturation.
 *
 * Thanks to Jack for starting me up, Tim for the parameter code, and Slee for the fade idea.
 */
class Life extends LXPattern {
  // Controls the rate of life algorithm ticks, in milliseconds
  private BasicParameter rateParameter = new BasicParameter("DELAY", 700, 0.0f, 10 * SECONDS);
  // Controls the probability of a mutation in the cycleOfLife
  private BasicParameter mutationParameter = new BasicParameter("MUT", 0.011f, 0.0f, 0.2f);
  // Controls the saturation.
  private BasicParameter saturationParameter = new BasicParameter("SAT", 75.0f, 0.0f, 100.0f);
  
  private BasicParameter neighborCountParameter = new BasicParameter("NEIG", 0.0f, -2.0f, 2.0f);

  // Alive probability ranges for randomization
  public final double MIN_ALIVE_PROBABILITY = 0.3f;
  public final double MAX_ALIVE_PROBABILITY = 0.5f;
  
  // The maximum brightness for an alive cell.
  public final float MAX_ALIVE_BRIGHTNESS = 75.0f;

  // Cube position oscillator used to select color. 
//  private final SawLFO facePos = new SawLFO(0, ((LEDome)model).getFaces().size(), 4000);
  private final SinLFO facePos = new SinLFO(0, model.yRange, 10 * SECONDS);

  // Contains the state of all cubes by index.
  // See L8onUtil.pde for definition of L8onFaceLife.
  private List<L8onFaceLife> face_lives;

  private List<LEDomeFace> faces;
  // Contains the amount of time since the last cycle of life.
  private int time_since_last_run;
  // Boolean describing if life changes were made during the current run.
  private boolean any_changes_this_run;
  // Hold the new lives
  private List<Boolean> new_lives;

  public Life(P2LX lx) {
     super(lx);
     this.faces = ((LEDome)model).faces;

     //Print debug info about the faces/edges.
     // outputFaceInfo();

     initFaceStates();
     time_since_last_run = 0;
     any_changes_this_run = false;
     new_lives = new ArrayList<Boolean>(this.faces.size());

     addParameter(rateParameter);
     addParameter(mutationParameter);
     addParameter(saturationParameter);
     addParameter(neighborCountParameter);

     addModulator(facePos).trigger();
  }

  public void run(double deltaMs) {
    any_changes_this_run = false;      
    new_lives.clear();
    time_since_last_run += deltaMs;

    for (L8onFaceLife face_life : this.face_lives) {
      LEDomeFace face = this.faces.get(face_life.index);

      if(shouldLightFace(face_life)) {
        lightLiveFace(face, face_life, deltaMs);
      } else if (face.hasLights()) {
        lightDeadFace(face, face_life, deltaMs);
      }
    }

    // If we have landed in a static state, randomize faces.
    if(!any_changes_this_run) {
      randomizeFaceStates();
    } else {
      // Apply new states AFTER ALL new states are decided.
      applyNewLives();
    }

    // Reset "tick" timer
    if(time_since_last_run >= rateParameter.getValuef()) {
      time_since_last_run = 0;
    }
  }

  /**
   * Light a live face.
   * Uses deltaMs for fade effect.
   */
  private void lightLiveFace(LEDomeFace face, L8onFaceLife face_life, double deltaMs) {
    float face_dist = LXUtils.wrapdistf(face.yf() - model.yMin, facePos.getValuef(), model.yRange);
    float hv = (face_dist / model.yRange) * 360;
    float bv = face_life.current_brightness;

    // Only change brightness if we are between "ticks" or if there is not enough time to fade.
    if(!face_life.just_changed || deltaMs >= rateParameter.getValuef()) {
      float bright_prop = min(((float) time_since_last_run / rateParameter.getValuef()), 1.0f);
      bv = min(MAX_ALIVE_BRIGHTNESS, bright_prop * MAX_ALIVE_BRIGHTNESS);

      if(face_life.current_brightness < bv) {
        face_life.current_brightness = bv;
      } else {
        bv = face_life.current_brightness;
      }
    }

    for (LXPoint p : face.points) {
      colors[p.index] = LX.hsb(
        hv,
        saturationParameter.getValuef(),
        bv
      );
    }
  }

  /**
   * Light a dead face.
   * Uses deltaMs for fade effect.
   */
  private void lightDeadFace(LEDomeFace face, L8onFaceLife face_life, double deltaMs) {
    float face_dist = LXUtils.wrapdistf(face.yf() - model.yMin, facePos.getValuef(), model.yRange);
    float hv = (face_dist / model.yRange) * 360;
    float bv = face_life.current_brightness;

    // Only change brightness if we are between "ticks" or if there is not enough time to fade.
    if(!face_life.just_changed || deltaMs >= rateParameter.getValuef()) {
      float bright_prop = 1.0f - min(((float) time_since_last_run / rateParameter.getValuef()), 1.0f);
      bv = max(0.0f, bright_prop * MAX_ALIVE_BRIGHTNESS);

      if(face_life.current_brightness > bv) {
        face_life.current_brightness = bv;
      } else {
        bv = face_life.current_brightness;
      }
    }
    
    for (LXPoint p : face.points) {
      colors[p.index] = LX.hsb(
        hv,
        saturationParameter.getValuef(),
        bv
      );   
    }
  }
 
  /**
   * Output debug info about the dome.
   */
  private void outputFaceInfo() {
    int i = 0;
    for (LEDomeEdge edge : ((LEDome)model).edges) {
      println("LEDomeEdge " + i + ": " + edge.xf() + "," + edge.yf() + "," + edge.zf());
      println("LEDomeEdge label: " + edge.he_halfedge.getLabel());
      ++i;
    }
  }

  /**
   * Initialize the list of face states.
   */
  private void initFaceStates() {
    boolean alive = false;
    L8onFaceLife face_life;
    this.face_lives = new ArrayList<L8onFaceLife>(this.faces.size());
    float current_brightness = 0.0f;

    for (int i=0; i< this.faces.size(); i++) {
      alive = false;
      face_life = new L8onFaceLife(i, alive, current_brightness);
      this.face_lives.add(face_life);
    }
  }

 /**
  * Randomizes the state of the cubes.
  * A value between MIN_ALIVE_PROBABILITY and MAX_ALIVE_PROBABILITY is chosen.
  * Each cube then has that probability of living.
  */
  private void randomizeFaceStates() {
    double prob_range = (1.0f - MIN_ALIVE_PROBABILITY) - (1.0f - MAX_ALIVE_PROBABILITY);
    double prob = MIN_ALIVE_PROBABILITY + (prob_range * Math.random());

    println("Randomizing faces p = " + prob);

    for (L8onFaceLife face_life : this.face_lives) {
      LEDomeFace face = this.faces.get(face_life.index);
      if (!face.hasLights()) {
        continue;
      }

      face_life.alive = (Math.random() <= prob);
    }
  }

  /**
   * Will initiate a cycleOfLife if it is time.
   * Otherwise responds based on the current state of the face.
   */
  private boolean shouldLightFace(L8onFaceLife face_life) {
    // Respect rate parameter.
    if(time_since_last_run < rateParameter.getValuef()) {
      any_changes_this_run = true;
      face_life.just_changed = false;
      return face_life.alive;
    } else {
      return cycleOfLife(face_life);
    }
  }

  /**
   * The meat of the life algorithm.
   * Uses the count of live neighbors and the face's current state
   * to decide the face's fate as such:
   * - If alive, needs 2 or 3 living neighbors to stay alive.
   * - If dead, needs 2 living neighbors to be born again.
   *
   * Populates the new_lives array and returns the new state of the cube.
   */
  private boolean cycleOfLife(L8onFaceLife face_life) {
    Integer index = face_life.index;
    LEDomeFace face = this.faces.get(index);

    // If the face has no lights, it is always dead.
    // Add to new_lives array to ensure cardinality of lists align.
    if (!face.hasLights()) {
      new_lives.add(false);  
      return false;
    }

    Integer alive_neighbor_count = countLiveNeighbors(face_life);
    boolean before_alive = face_life.alive;
    boolean after_alive = before_alive;
    double mutation = Math.random();
    int neighbor_count_delta = (int) neighborCountParameter.getValue();
    int alive_min_neighbors = (2 + neighbor_count_delta);
    int alive_max_neighbors = (3 + neighbor_count_delta);
    int dead_to_alive_neighbors = (3 + neighbor_count_delta);

    if (face.getNeighbors().size() > 9) {
      neighbor_count_delta++;
    }

    if(face_life.alive) {
      if(alive_neighbor_count < alive_min_neighbors || alive_neighbor_count > alive_max_neighbors) {
        after_alive = false;
      } else {
        after_alive = true;
      }
    } else {
      if(alive_neighbor_count == dead_to_alive_neighbors) {
        after_alive = true;
      } else {
        after_alive = false;
      }
    }

    if(mutation <= mutationParameter.getValuef()) {
      after_alive = !after_alive;
    }

    if(before_alive != after_alive) {
      face_life.just_changed = true;
      any_changes_this_run = true;
    }

    new_lives.add(after_alive);

    return before_alive;
  }
   
  /**
   * Counts the number of living neighbors of a cube.
   */
  private Integer countLiveNeighbors(L8onFaceLife face_life) {
    Integer count = 0;
    L8onFaceLife neighbor_life;

    for(Integer neighbor_index : this.faces.get(face_life.index).getNeighbors()) {
       neighbor_life = this.face_lives.get(neighbor_index);
       if(neighbor_life.alive) {
         count++;
       }
    }

    return count;
  }

  /**
   * Apply the new states from the new_lives array.
   */
  private void applyNewLives() {
    if (this.new_lives.size() == 0) {
      return;
    }

    for(int index = 0; index < this.face_lives.size(); index++) {
      L8onFaceLife face_life = this.face_lives.get(index);
      face_life.alive = new_lives.get(index);
      index++;
    }
  }
}

class ExplosionEffect extends LXEffect {
  // Used to store info about each explosion.
  // See L8onUtil.pde for the definition.
  private List<ExplosionLayer> explosion_layers = new ArrayList<ExplosionLayer>();

  private BasicParameter brightnessParameter = new BasicParameter("BRGT", 90, 10, 80);
  private BasicParameter saturationParameter = new BasicParameter("SAT", 60, 0, 100);
  private BasicParameter rateParameter = new BasicParameter("RATE", 400.0f, 100.0f, 20000.0f);
  private BasicParameter delayParameter = new BasicParameter("DELAY", 1000.0f, 10.0f, 3000.0f);
  final float maxr = sqrt(model.xMax*model.xMax + model.yMax*model.yMax + model.zMax*model.zMax) + 10;
  private BasicParameter strokeParameter = new BasicParameter("STRK", 15.0f, 3.0f, maxr / 2.0f);
  
  class ExplosionLayer {
    QuadraticEnvelope boom = new QuadraticEnvelope(0, maxr, rateParameter);
    L8onExplosion explosion;

    ExplosionLayer() {
      boom = new QuadraticEnvelope(0, maxr, rateParameter);
      boom.setEase(QuadraticEnvelope.Ease.OUT);
      WB_Point new_center = ((LEDome)model).randomFaceCenter();
      addModulator(boom);
      explosion = new L8onExplosion(boom, strokeParameter.getValuef(), new_center.xf(), new_center.yf(), new_center.zf());
      trigger();
    }

    public void trigger() {
      WB_Point new_center = ((LEDome)model).randomFaceCenter();
      explosion.setCenter(new_center.xf(), new_center.yf(), new_center.zf());
      explosion.explode();
    }

    public void run(double deltaMs) {      
      float brightv = brightnessParameter.getValuef();
      float satv = saturationParameter.getValuef();
      float huev = lx.getBaseHuef();
      for (LXPoint p : model.points) {
        if (explosion.onExplosion(p.x, p.y, p.z)) {
          addColor(p.index, LX.hsb(huev, satv, brightv));
        } else {
          int c = colors[p.index];
          addColor(p.index, LX.hsb(LXColor.h(c), LXColor.s(c), L8onUtil.decayed_brightness(c, delayParameter.getValuef(), deltaMs)));
        }
      }
    }
  }

  public ExplosionEffect(LX lx) {
    super(lx, true);

    addParameter(brightnessParameter);
    addParameter(saturationParameter);
    addParameter(rateParameter);
    addParameter(delayParameter);
    addParameter(strokeParameter);; }

 public void onEnable() {
    for (ExplosionLayer l : explosion_layers) {
      if (!l.explosion.isExploding()) {
        l.trigger();
        return;
      }
    }

    explosion_layers.add(new ExplosionLayer());
  }

  public void run(double deltaMs) {
    for (ExplosionLayer l : explosion_layers) {
      if (l.explosion != null && l.explosion.isExploding()) {
        l.run(deltaMs);
      }
    }
  }
}

//class Ripples extends LXPattern {
//  // Used to store info about each ripple.
//  // See L8onUtil.pde for the definition.
//  private List<L8onRipple> ripples = new ArrayList<L8onRipple>();
//
//  private final SinLFO saturationModulator = new SinLFO(70.0, 90.0, 20 * SECONDS);
//
//  private BasicParameter numRipplesParameter = new BasicParameter("NUM", 2.0, 1.0, 30.0);
//  private BasicParameter brightnessParameter = new BasicParameter("BRGT", 50, 10, 80);
//  private BasicParameter rateParameter = new BasicParameter("RATE", 4000.0, 500.0, 20000.0);
//  private BasicParameter blurParameter = new BasicParameter("BLUR", 0.69, 0.0, 1.0);
//
//  private BlurLayer blurLayer = new BlurLayer(lx, this, blurParameter);
//
//  public Ripples(P2LX lx) {
//    super(lx);
//
//    addParameter(numRipplesParameter);
//    addParameter(brightnessParameter);
//    addParameter(rateParameter);
//    addParameter(blurParameter);
//
//    addLayer(blurLayer);
//    addModulator(saturationModulator).start();
//
//    initRipples();
//  }
//
//  public void run(double deltaMs) {
//    initRipples();
//
//    float base_hue = lx.getBaseHuef();
//    float wave_hue_diff = (float) (360.0 / this.ripples.size());
//
//    for(L8onRipple ripple : this.ripples) {
//      if (ripple.isChillin((float)deltaMs)) {
//        continue;
//      }
//
//      ripple.hue_value = (float)(base_hue % 360.0);
//      base_hue += wave_hue_diff;
//
//      if (!ripple.hasExploded()) {
//        ripple.explode();
//      } else if (ripple.isFinished()) {
//        assignNewCenter(ripple);
//      }
//    }
//   
//    float sat_value = saturationModulator.getValuef();
//    float brightness_value = brightnessParameter.getValuef();
//
//    for (LXPoint p : model.points) {
//      int num_ripples_in = 0;
//
//      for(L8onRipple ripple : this.ripples) {
//        if(ripple.isChillin(0)) {
//          continue;
//        }
//
//        float point_amplitude = ripple.amplitude(p.x, p.y, p.z);
//
//        if (point_amplitude <= 0.01) {
//          continue;    
//        }
//
//        num_ripples_in++;
//
//        if (num_ripples_in == 1) {
//          setColor(p.index, LXColor.hsb(ripple.hue_value, sat_value, (point_amplitude * brightness_value)));
////          setColor(p.index, LXColor.hsb(ripple.hue_value, point_amplitude * sat_value, brightness_value));
//        } else {
//          blendColor(p.index, LXColor.hsb(ripple.hue_value, sat_value, (point_amplitude * brightness_value)), LXColor.Blend.SCREEN);
////          blendColor(p.index, LXColor.hsb(ripple.hue_value, point_amplitude * sat_value, brightness_value), LXColor.Blend.LERP);
//        }
//      }
//
//      if (num_ripples_in == 0) {
//        color old_color = colors[p.index];
//        color new_color = LX.hsb(LXColor.h(old_color), LXColor.s(old_color), 0.0);
////        setColor(p.index, new_color);
//        colors[p.index] = new_color;
//      }
//    }   
//  }
//
//  private void initRipples() {
//    int num_ripples = (int) numRipplesParameter.getValue();
//
//    if (this.ripples.size() == num_ripples) {
//      return;
//    }
//
//    if (this.ripples.size() < num_ripples) {
//      for(int i = 0; i < (num_ripples - this.ripples.size()); i++) {
//        QuadraticEnvelope new_radius_env = new QuadraticEnvelope(0.0, model.xRange * 3.0, rateParameter);
//        QuadraticEnvelope new_decay_env = new QuadraticEnvelope(1.0, 0.0, rateParameter);
//        WB_Point new_center = ((LEDome)model).randomFaceCenter();
//        addModulator(new_radius_env);
//        addModulator(new_decay_env);
//        this.ripples.add(
//          new L8onRipple(new_radius_env, new_decay_env, new_center.xf(), new_center.yf(), new_center.zf())
//        );
//      }
//    } else {
//      for(int i = (this.ripples.size() - 1); i >= num_ripples; i--) {
//        this.ripples.remove(i);
//      }
//    }
//  }
//
//  private void assignNewCenter(L8onRipple ripple) {
//    WB_Point new_center = ((LEDome)model).randomFaceCenter();
//    float chill_time = (3.0 + random(7)) * SECONDS;    
//    QuadraticEnvelope new_radius_env = new QuadraticEnvelope(0.0, model.xRange * 5.0, rateParameter);
//    LinearEnvelope new_decay_env = new LinearEnvelope(1.0, 0.0, rateParameter);
//    
//    ripple.setCenter(new_center.xf(), new_center.yf(), new_center.zf());
//    addModulator(new_radius_env);
//    addModulator(new_decay_env);
//    ripple.setRadiusModulator(new_radius_env, new_decay_env);
//    ripple.setChillTime(chill_time);
//  }
//}
static class L8onUtil {
  L8onUtil() {
  }
  
  public static float decayed_brightness(int c, float delay,  double deltaMs) {
    float bright_prop = min(((float)deltaMs / delay), 1.0f);
    float bright_diff = max((LXColor.b(c) * bright_prop), 1);
    return max(LXColor.b(c) - bright_diff, 0.0f);
  }
}

public class SnakeLayer extends LXLayer {
  private static final float BRIGHTNESS = 80.0f;
  private static final int NUM_EDGES = 2;
  private static final int NUM_POINTS = (NUM_EDGES * 3) + 3;
  private static final float SNAKE_SPEED = 36.0f;
  
  private int[] snakeColors = new int[model.points.size()];
  private List<LEDomeEdge> snakeEdges = new ArrayList<LEDomeEdge>();
  private List<LXPoint> snakePoints = new ArrayList<LXPoint>();  
  private List<LXPoint> pointQueue = new ArrayList<LXPoint>();
  
  public float hue = -1.0f;
  
  private LXRangeModulator xMod = new LinearEnvelope(0);
  private LXRangeModulator yMod = new LinearEnvelope(0);
  private LXRangeModulator zMod = new LinearEnvelope(0);

  private BasicParameter brightness;  
  private BasicParameter numPoints;
  private BasicParameter snakeSpeed;
  
  public SnakeLayer(LX lx) {
    this(lx, new BasicParameter("EDG", NUM_POINTS), new BasicParameter("SPD", SNAKE_SPEED), new BasicParameter("BRIT", BRIGHTNESS));  
  }
  
  public SnakeLayer(LX lx, BasicParameter numPoints, BasicParameter snakeSpeed, BasicParameter brightness) {
    super(lx);    
    this.numPoints = numPoints;
    this.snakeSpeed = snakeSpeed;
    this.brightness = brightness;
    this.restartSnake();
    
    addModulator(this.xMod);
    addModulator(this.yMod);
    addModulator(this.zMod);
  }

  public void run(double deltaMs) {      
    if (this.reachedTarget()) {
      if (this.pointQueue.size() > 1) {
        this.addPointToSnake(this.pointQueue.get(1));
      }
      
      this.pickNextTarget();
      this.startMovement();
      return;
    }
    
    float modBasis = (this.xMod.getBasisf() + this.yMod.getBasisf() + this.zMod.getBasisf()) / 3.0f;
    float brightnessProp = 1.0f;      
     
    for (LXPoint p : model.points) {
      int snakeIndex = this.snakePoints.indexOf(p);
      
      if (snakeIndex >= 0) {
        if (snakeIndex == 0) {
          brightnessProp = max(1.0f - modBasis, 0.0f);
          
          snakeColors[p.index] = LX.hsb(this.hueValue(), 80, brightnessProp * brightness.getValuef());          
          continue;
        }
        
        if (snakeIndex == (this.snakePoints.size() - 1)) {
          brightnessProp = min(modBasis, 1.0f);
          snakeColors[p.index] = LX.hsb(this.hueValue(), 80, brightnessProp * brightness.getValuef());          
          continue;    
        }

        snakeColors[p.index] = LX.hsb(this.hueValue(), 80, brightness.getValuef());
        continue;
      }
      
      snakeColors[p.index] = LX.hsb(0, 0, 0);
    }
  }
  
  public float hueValue() {
    return (this.hue >= 0.0f) ? this.hue : lx.getBaseHuef();
  }
  
  public boolean hasPoint(LXPoint point) {
    return this.snakePoints.contains(point);  
  }
  
  public int colorOf(int index) {
    return this.snakeColors[index];  
  }

  private void addPointToSnake(LXPoint point) {
    this.snakePoints.add(point);      
    
    while (this.snakePoints.size() > this.maxSnakePoints()) {              
      this.snakePoints.remove(0);
    }      
  }
  
  private int maxSnakePoints() {
    return (int)this.numPoints.getValue();  
  }
  
  private boolean reachedTarget() {
    return !this.xMod.isRunning() && !this.yMod.isRunning() && !this.zMod.isRunning();   
  }
  
  private void restartSnake() {      
    this.snakePoints.clear();      
    this.snakeEdges.clear();      
    this.pointQueue.clear();
    LEDomeEdge firstEdge = ((LEDome)model).randomEdge();
    
    this.snakeEdges.add(firstEdge);    
    
    this.pointQueue.add(firstEdge.points.get(0));
    this.pointQueue.add(firstEdge.points.get(1));
    this.pointQueue.add(firstEdge.points.get(2));
  }
  
  private void startMovement() {
    if (this.pointQueue.size() < 2) { return; }

    LXPoint origin = this.pointQueue.get(0);
    LXPoint target = this.pointQueue.get(1);
    double travelTime = this.timeToTravel(origin, target);
    this.xMod.setRange((double)origin.x, (double)target.x, travelTime).start();
    this.yMod.setRange((double)origin.y, (double)target.y, travelTime).start();
    this.zMod.setRange((double)origin.z, (double)target.z, travelTime).start();
  }
  
  private void pickNextTarget() {      
    // Remove old origin.
    if (this.pointQueue.size() > 1) {
      this.pointQueue.remove(0);
    }
    
    // We still have 2+ points to hit, do nothing. 
    if (this.pointQueue.size() > 1) { return; }
          
    this.findNextEdge();
    
    // If the queue somehow stays empty, restart it yo.
    if (this.pointQueue.size() == 0) {
      this.restartSnake();
    }
  }
  
  private void findNextEdge() {
    LXPoint origin = this.pointQueue.get(0);
    HE_Vertex originVertex = ((LEDome)model).closestVertex(origin);
    List<HE_Halfedge> neighbors = originVertex.getHalfedgeStar();
    Collections.shuffle(neighbors);
    boolean foundEdge = false;

    for(HE_Halfedge he_edge : neighbors) {
      // Skip edges without labels
      if (he_edge.getLabel() < 0) { continue; }

      // Find the LEDomeEdge with the correct label. 
      LEDomeEdge edge = ((LEDome)model).edges.get(he_edge.getLabel());

      // Continue if the edge doesn't have lights or if the edge is already in the snake.
      if (edge == null || this.snakeEdges.contains(edge)) { continue; }

      // Hey we found an edge!
      foundEdge = true;
           
      this.queueEdgePoints(origin, edge);      

      if (this.shouldRemoveTail()) {
        this.removeTail();
      }

      this.snakeEdges.add(edge);
      break;
    }
    
    // Clear the pointQueue if we couldn't find another edge.
    if (!foundEdge) {
      this.restartSnake();
    }
  }
  
  private void queueEdgePoints(LXPoint origin, LEDomeEdge edge) {
    // Get the next vertex
    LXPoint closestPoint = edge.closestVertexPoint(origin.x, origin.y, origin.z);
    
    if (closestPoint != origin) {
      this.pointQueue.add(closestPoint);
    }

    this.pointQueue.add(edge.points.get(1));

    if (closestPoint == edge.points.get(0)) {
      this.pointQueue.add(edge.points.get(2));      
    } else {
      this.pointQueue.add(edge.points.get(0));
    }
  }

  private boolean shouldRemoveTail() {
    return this.snakeEdges.size() >= this.maxSnakeEdges();
  }
  
  private int maxSnakeEdges() {
    return ceil(this.maxSnakePoints() / 3.0f);  
  }

  private void removeTail() {
    this.snakeEdges.remove(0);
  }

  private double timeToTravel(LXPoint firstHeadPoint, LXPoint secondHeadPoint) {
    float distToTravel = dist(firstHeadPoint.x, firstHeadPoint.y, firstHeadPoint.z, secondHeadPoint.x, secondHeadPoint.y, secondHeadPoint.z);
    return max(distToTravel / (snakeSpeed.getValuef() / SECONDS), 0.0f);      
  }
}

public class OffLayer extends LXLayer {
  private int black = LX.hsb(0, 0, 0);
  
  public OffLayer(LX lx, LXBufferedComponent pattern) {
    super(lx, pattern);
  }
  
  public void run(double deltaMs) {  
    for (LXPoint p : model.points) {
      setColor(p.index, black);  
    }
  }
}


public class BlurLayer extends LXLayer {
  public final BasicParameter amount;
  private final int[] blurBuffer;

  public BlurLayer(LX lx, LXBufferedComponent pattern) {
    this(lx, pattern, new BasicParameter("BLUR", 0));
  }

  public BlurLayer(LX lx, LXBufferedComponent pattern, BasicParameter amount) {    
    super(lx, pattern);    
    this.amount = amount;
    this.blurBuffer = new int[lx.total];
    
    for (int i = 0; i < blurBuffer.length; ++i) {
      this.blurBuffer[i] = 0xff000000;
    }
  }
  
  public void run(double deltaMs) {
    float blurf = this.amount.getValuef();
    if (blurf > 0) {
      blurf = 1 - (1 - blurf) * (1 - blurf) * (1 - blurf);
      for (int i = 0; i < this.colors.length; ++i) {
        int blend = LXColor.screen(this.colors[i], this.blurBuffer[i]);
        this.colors[i] = LXColor.lerp(this.colors[i], blend, blurf);
      }
    }
    for (int i = 0; i < this.colors.length; ++i) {
      this.blurBuffer[i] = this.colors[i];
    }
  }
}

/*
 * A container to keep state of the different 3d waves in the color remix.
 */
class L8onWave {
  public static final int DIRECTION_X = 1;
  public static final int DIRECTION_Y = 2;
  public static final int DIRECTION_Z = 3;

  int direction;
  float offset_multiplier;
  float hue_value;

  public L8onWave(int direction, float offset_multiplier) {
    this.direction = direction;
    this.offset_multiplier = offset_multiplier;
  }
}

class L8onSpotLight {   
  WB_Sphere sphere;
  float center_x;
  float center_y;
  float center_z;
  float dest_x;
  float dest_y;
  float dest_z;  
  float hue_value;
  float min_dist;
  float time_at_dest_ms;
  
  public L8onSpotLight(WB_Sphere sphere, float center_x, float center_y, float center_z, float dest_x, float dest_y, float dest_z, float min_dist) {    
    this.sphere = sphere;
    WB_Point sphereCenterPoint = sphere.projectToSphere(new WB_Point(center_x, center_y, center_z));
    WB_Point sphereDestPoint = sphere.projectToSphere(new WB_Point(dest_x, dest_y, dest_z));
    this.time_at_dest_ms = 0.0f;
    this.center_x = sphereCenterPoint.xf();
    this.center_y = sphereCenterPoint.yf();
    this.center_z = sphereCenterPoint.zf();
    this.dest_x = sphereDestPoint.xf();
    this.dest_y = sphereDestPoint.yf();
    this.dest_z = sphereDestPoint.zf();
    this.min_dist = min_dist;
  }
  
  public void tryNewDestination() {    
    float new_x = model.xMin + random(model.xRange);    
    float new_y = model.yMin + random(model.yRange);
    float new_z = model.zMin + random(model.zRange);
    
    if (min_dist <= dist(center_x, center_y, center_z, new_x, new_y, new_z)) { 
      this.setDestination(new_x, new_y, new_z);  
    } 
  }
  
  public void setDestination(float dest_x, float dest_y, float dest_z) {    
    WB_Point spherePoint = sphere.projectToSphere(new WB_Point(dest_x, dest_y, dest_z));
    this.dest_x = spherePoint.xf();
    this.dest_y = spherePoint.yf();
    this.dest_z = spherePoint.zf();    
    this.time_at_dest_ms = 0.0f;
  }
  
  public void addTimeAtDestination(float delta) {
    this.time_at_dest_ms += delta;  
  }
  
  public float distFromDestination() {
    return dist(center_x, center_y, center_z, dest_x, dest_y, dest_z);  
  }
  
  public void movePercentageTowardDestination(float perc) {
    float dist_x = abs(dest_x - center_x) * perc;
    float dist_y = abs(dest_y - center_y) * perc;
    float dist_z = abs(dest_z - center_z) * perc;   
    
    this.moveTowardDestination(dist_x, dist_y, dist_z);
  }
  
  public void moveTowardDestination(float dist_x, float dist_y, float dist_z) {
    if (center_x < dest_x) {
      center_x = min(dest_x, center_x + dist_x);    
    } else {
      center_x = max(dest_x, center_x - dist_x);
    }
    
    if (center_y < dest_y) {
      center_y = min(dest_y, center_y + dist_y);    
    } else {
      center_y = max(dest_y, center_y - dist_y);
    }
    
    if (center_z < dest_z) {
      center_z = min(dest_z, center_z + dist_z);    
    } else {
      center_z = max(dest_z, center_z - dist_z);
    }
    
    WB_Point spherePoint = sphere.projectToSphere(new WB_Point(center_x, center_y, center_z));
    center_x = spherePoint.xf();
    center_y = spherePoint.yf();
    center_z = spherePoint.zf();
  }  
}

/**
 * Base class for keeping the state of a shape for a
 * game of life simulation.
 */
class L8onFaceLife {
  // Index of face
   public Integer index;
   // Boolean which describes if shape is alive.
   public boolean alive;
   // Boolean which describes if strip was just changed;
   public boolean just_changed;
   // Current brightness
   public float current_brightness;

   public L8onFaceLife(Integer index, boolean alive, float current_brightness) {
     this.index = index;
     this.alive = alive;
     this.current_brightness = current_brightness;
     this.just_changed = false;
   }
}

/**
 * Contains the current state of an explosion.
 */
class L8onExplosion {
  float radius;
  float center_x;
  float center_y;
  float center_z;  
  float stroke_width;
  float hue_value;
  float chill_time;
  float time_chillin;
  
  private LXModulator radius_modulator;
  private boolean radius_modulator_triggered = false;  
  
  private float _min_dist;
  private float _max_dist;
  
  public L8onExplosion(float radius, float stroke_width, float center_x, float center_y, float center_z) {    
    this.setRadius(radius, stroke_width);
    this.center_x = center_x;
    this.center_y = center_y;
    this.center_z = center_z;
  }
  
  public L8onExplosion(LXModulator radius_modulator, float stroke_width, float center_x, float center_y, float center_z) {    
    this.setRadiusModulator(radius_modulator, stroke_width);
    this.center_x = center_x;
    this.center_y = center_y;
    this.center_z = center_z;
  }
    
  public void setChillTime(float chill_time) {
    this.chill_time = chill_time;  
    this.time_chillin = 0;
  }
  
  public boolean isChillin(float deltaMs) {
    this.time_chillin += deltaMs;
    
    return time_chillin < this.chill_time;  
  }
  
  public float distanceFromCenter(float x, float y, float z) {
    return dist(this.center_x, this.center_y, this.center_z, x, y, z);
  }

  public void setRadius(float new_radius) {
    this.radius = new_radius;
    this._min_dist = max(0.0f, radius - (stroke_width / 2.0f));
    this._max_dist = radius + (stroke_width / 2.0f);
  }
  
  public void setRadius(float new_radius, float stroke_width) {
    this.stroke_width = stroke_width;
    this.setRadius(new_radius);
  }
  
  public void setRadiusModulator(LXModulator radius_modulator, float stroke_width) {
    this.radius_modulator = radius_modulator;
    this.stroke_width = stroke_width;    
    this.radius_modulator_triggered = false;
  }

  public void setCenter(float x, float y, float z) {
    this.center_x = x;
    this.center_y = y;
    this.center_z = z;  
  }
  
  public void explode() {
    this.radius_modulator_triggered = true;    
    this.radius_modulator.trigger();
  }
  
  public boolean hasExploded() {
    return this.radius_modulator_triggered;  
  }
  
  public boolean isExploding() {
    if (this.radius_modulator == null) {
      return false;
    }
    
    return this.radius_modulator.isRunning();    
  }
  
  public boolean isFinished() {
    if (this.radius_modulator == null) {
      return true;
    }
    
    return !this.radius_modulator.isRunning();    
  }
  
  public boolean onExplosion(float x, float y, float z) {    
    float current_radius = this.radius_modulator.getValuef();
    float min_dist = max(0.0f, current_radius - (stroke_width / 2.0f));
    float max_dist = current_radius + (stroke_width / 2.0f);;
    float point_dist = this.distanceFromCenter(x, y, z);
        
    return (point_dist >= min_dist && point_dist <= max_dist);  
  }
}

/**
 * Contains the current state of an explosion.
 */
class L8onRipple {
  float radius;
  float center_x;
  float center_y;
  float center_z;
  float hue_value;
  float chill_time;
  float time_chillin;
  float decay;
  
  private LXModulator radius_modulator;
  private LXModulator decay_modulator;
  private boolean radius_modulator_triggered = false;
  
  public L8onRipple(LXModulator radius_modulator, LXModulator decay_modulator, float center_x, float center_y, float center_z) {    
    this.setRadiusModulator(radius_modulator, decay_modulator);
    this.center_x = center_x;
    this.center_y = center_y;
    this.center_z = center_z;
  }
    
  public void setChillTime(float chill_time) {
    this.chill_time = chill_time;  
    this.time_chillin = 0;
  }
  
  public boolean isChillin(float deltaMs) {
    this.time_chillin += deltaMs;
    return time_chillin < this.chill_time;  
  }
  
  public float distanceFromCenter(float x, float y, float z) {
    return dist(this.center_x, this.center_y, this.center_z, x, y, z);
  }
    
  public void setRadiusModulator(LXModulator radius_modulator, LXModulator decay_modulator) {    
    this.decay_modulator = decay_modulator;
    this.radius_modulator = radius_modulator;
    this.radius_modulator_triggered = false;
  }

  public void setCenter(float x, float y, float z) {
    this.center_x = x;
    this.center_y = y;
    this.center_z = z;
  }

  public void explode() {
    this.radius_modulator_triggered = true;    
    this.radius_modulator.trigger();
    this.decay_modulator.trigger();
  }
  
  public boolean hasExploded() {
    return this.radius_modulator_triggered;
  }

  public boolean isExploding() {
    if (this.decay_modulator == null) {
      return false;
    }

    return this.decay_modulator.isRunning();    
  }
  
  public boolean isFinished() {
    if (this.decay_modulator == null) {
      return true;
    }
    
    return !this.decay_modulator.isRunning();    
  }

  public float amplitude(float x, float y, float z) {    
    float current_radius = this.radius_modulator.getValuef();
    float decay_perc = this.decay_modulator.getValuef();    
    float point_dist = this.distanceFromCenter(x, y, z);
    float offset = current_radius - point_dist;
   
    // The point is beyond the event horizon. 
    if (offset < 0) { return 0.0f; }
    
    float point_perc = point_dist / current_radius;
    float period = min(current_radius, 10);
    float period_dist = offset / period;    
    float raw_amplitude = (sin(period_dist * PI) + 1.0f) / 2.0f;
     
     
    return raw_amplitude * (1.0f - point_perc) * decay_perc;
//    return raw_amplitude;
//    return raw_amplitude * (this.decay * point_perc);
  }
}
/**
 *     DOUBLE BLACK DIAMOND        DOUBLE BLACK DIAMOND
 *
 *         //\\   //\\                 //\\   //\\  
 *        ///\\\ ///\\\               ///\\\ ///\\\
 *        \\\/// \\\///               \\\/// \\\///
 *         \\//   \\//                 \\//   \\//
 *
 *        EXPERTS ONLY!!              EXPERTS ONLY!!
 *
 * This file implements the mapping needed to generate, identify and order 
 * each face dome and plots the lights on the faces. It should only be modified
 * when physical changes or tuning is being done to the structure.
 */

// Let's work in inches
final static int INCHES = 1;
final static int FEET = 12*INCHES;

// Let's work with human level times.
final static int SECONDS = 1000;
final static int MINUTES = 60 * SECONDS;

// Configure the NDB and the number of connected lights.
final static int NUM_CONNECTED_LIGHTS = 30;
final static String NDB_IP_ADDRESS = "10.0.0.116";

/**
 * This is a very basic model class that is a 3-D matrix
 * of points. The model contains just one fixture.
 */
static class LEDome extends LXModel {
  public List<LEDomeFace> faces;
  public List<LEDomeEdge> edges;
  public WB_Sphere sphere;

  private LEDomeLights domelights;

  public static final float DOME_RADIUS = 5.5f * FEET;  
  
  public static final int DIRECTION_RIGHT = 0;
  public static final int DIRECTION_FORWARD = 1;
  public static final int DIRECTION_LEFT = 2;
  public static final int DIRECTION_BACK = 3;
  
  public static final int CLOCKWISE = 0;
  public static final int COUNTER_CLOCKWISE = 1;
  public static final int LIGHT_DIRECTION = COUNTER_CLOCKWISE;
    
  public static final ArrayList<Integer> NO_LIGHT_FACES = new ArrayList<Integer>(Arrays.asList(16, 17, 18, 47, 48, 49, 75, 76));
    
  public static final ArrayList<Integer> TEST_LIST = new ArrayList<Integer>(Arrays.asList(100, 101, 102, 103, 104));
  
  public static final ArrayList<Integer> FACE_LIST_0 = new ArrayList<Integer>(Arrays.asList(20, 19, 50, 51, 78, 77, 95, 96, 104));  
  public static final ArrayList<Integer> FACE_LIST_1 = new ArrayList<Integer>(Arrays.asList(21, 22, 23, 54, 53, 52, 80, 79, 97, 98));
  public static final ArrayList<Integer> FACE_LIST_2 = new ArrayList<Integer>(Arrays.asList(25, 24, 56, 55, 81, 82, 83, 84, 99, 100));
  public static final ArrayList<Integer> FACE_LIST_3 = new ArrayList<Integer>(Arrays.asList(26, 27, 28, 58, 57, 59, 60, 61, 86, 85));
  public static final ArrayList<Integer> FACE_LIST_4 = new ArrayList<Integer>(Arrays.asList(1, 0, 29, 30, 31, 32, 63, 62, 87, 101));
  public static final ArrayList<Integer> FACE_LIST_5 = new ArrayList<Integer>(Arrays.asList(2, 3, 4, 34, 33, 35, 65, 64, 88, 89));
  public static final ArrayList<Integer> FACE_LIST_6 = new ArrayList<Integer>(Arrays.asList(7, 6, 5, 36, 37, 38, 66, 67, 90, 102));
  public static final ArrayList<Integer> FACE_LIST_7 = new ArrayList<Integer>(Arrays.asList(8, 9, 10, 41, 40, 39, 68, 69, 70, 91));
  public static final ArrayList<Integer> FACE_LIST_8 = new ArrayList<Integer>(Arrays.asList(13, 12, 11, 42, 43, 44, 73, 72, 71, 92));
  public static final ArrayList<Integer> FACE_LIST_9 = new ArrayList<Integer>(Arrays.asList(14, 15, 46, 45, 74, 94, 93, 103));
    
  private Random randomFaceIndex = new Random();

  public LEDome() {
    super(new LEDomeLights());
    this.domelights = ((LEDomeLights)fixtures.get(0));
    this.sphere = new WB_Sphere(domelights.geodome.getCenter(), DOME_RADIUS);
    this.faces = this.getFaces();
    this.edges = this.getEdges();
  }
 
  public HE_Mesh getLEDomeMesh() {
    return this.domelights.geodome;
  }
  
  public List<LEDomeFace> getFaces() {
    return this.domelights.faces;
  }
  
  public List<LEDomeEdge> getEdges() {
    return this.domelights.edges;
  }
  
  public LEDomeFace randomFace() {    
    return this.domelights.faces.get(randomFaceIndex.nextInt(domelights.faces.size()));  
  }
  
  public WB_Point randomFaceCenter() {
    return this.randomFace().he_face.getFaceCenter();  
  }
    
  public HE_Vertex randomVertex() {
    return this.domelights.geodome.getVertexByIndex(randomFaceIndex.nextInt(domelights.geodome.getNumberOfVertices()));  
  }
   
   public HE_Vertex closestVertex(LXPoint p) {
    return this.closestVertex(p.x, p.y, p.z);
  }
  
  public HE_Vertex closestVertex(float x, float y, float z) {
    return this.domelights.geodome.getClosestVertex(new WB_Point(x, y, z), this.domelights.vertexTree);
  }
    
  public LEDomeEdge randomEdge() {
    return this.domelights.edges.get(randomFaceIndex.nextInt(domelights.edges.size()));  
  }

  public WB_Point projectToSphere(float x, float y, float z) {
    return this.projectToSphere(new WB_Point(x, y, z));
  }
  
  public WB_Point projectToSphere(WB_Point point) {
    return this.sphere.projectToSphere(point); 
  }
    
 
  private static class LEDomeLights extends LXAbstractFixture {
    public HE_Mesh geodome;
    public WB_KDTree<WB_Point, Long> vertexTree;
    public ArrayList<List<Integer>> lightStringFaceLists = new ArrayList<List<Integer>>();
    public List<LEDomeFace> faces = new ArrayList<LEDomeFace>();
    public List<LEDomeEdge> edges = new ArrayList<LEDomeEdge>();

    public static final double LIGHT_OFFSET_PROP = 0.3f;
    public static final boolean DEBUG = false;
    
    private LEDomeLights() {
       buildGeodome();
       createLEDFaces();
       initializeLightStringFaceLists();       
       plotLightsOnDome();
       
       if (DEBUG) {
         outputDebugInfo();
       }
    }
    
    private void buildGeodome() {    
      HEC_Geodesic creator = new HEC_Geodesic();  
      creator.setRadius(DOME_RADIUS); 
      
      // http://stackoverflow.com/questions/3031875/math-for-a-geodesic-sphere
      // N=B+C=number of divisions
      // B=N and C=0 or B=0 and C=N: class I
      // B=C=N/2: class II
      // Other: class III 
      creator.setB(3);
      creator.setC(0);
    
      // class I, II and III: TETRAHEDRON,OCTAHEDRON,ICOSAHEDRON
      // class II only: CUBE, DODECAHEDRON
      creator.setType(HEC_Geodesic.ICOSAHEDRON);
      creator.setCenter(0, 0, 0);
      
      // Make the ZAxis the YAxis. Will generate with correct "top"
      creator.setZAxis(0, 1, 0);
      HE_Mesh geosphere = new HE_Mesh(creator); 
        
      HE_Selection selection = new HE_Selection(geosphere);
      HE_FaceIterator fItr = new HE_FaceIterator(geosphere);    
      
      while (fItr.hasNext()) {
        HE_Face face = fItr.next();
        if (face.getFaceCenter().yd() > -5 * INCHES) {        
          selection.add(face);
        }
      }
      
      this.geodome = selection.getAsMesh();
      this.vertexTree = (WB_KDTree<WB_Point, Long>)(WB_KDTree<?, Long>)geodome.getVertexTree();
    }
             
    private void initializeLightStringFaceLists() {      
//      lightStringFaceLists.add(TEST_LIST);
      lightStringFaceLists.add(FACE_LIST_0);
      lightStringFaceLists.add(FACE_LIST_1);
      lightStringFaceLists.add(FACE_LIST_2);
      lightStringFaceLists.add(FACE_LIST_3);
      lightStringFaceLists.add(FACE_LIST_4);
      lightStringFaceLists.add(FACE_LIST_5);
      lightStringFaceLists.add(FACE_LIST_6);
      lightStringFaceLists.add(FACE_LIST_7);
      lightStringFaceLists.add(FACE_LIST_8);
      lightStringFaceLists.add(FACE_LIST_9);
    }

    private void createLEDFaces() {
      int currDirection = DIRECTION_RIGHT;
      HE_Face currFace = getFirstFace();
      HE_Face nextFace;

      for (int i = 0; i < geodome.getNumberOfFaces(); i++) {
        faces.add(new LEDomeFace(currFace));
        currFace.setLabel(i);            
        nextFace = getNextFaceInDirection(currFace, currDirection);
        
        if (nextFace == null) {
          currDirection = nextDirection(currDirection);
          nextFace = getNextFaceInDirection(currFace, currDirection);
        }

        currFace = nextFace;        
      }
    }     

    private HE_Face getNextFaceInDirection(HE_Face face, int direction) {
      List<HE_Face> neighborFaces = face.getNeighborFaces();                  
      HE_Face nextFace = null;            
            
      switch(direction) {          
        case DIRECTION_RIGHT:
          nextFace = nextRightFace(face, neighborFaces);
          break;
        case DIRECTION_FORWARD:
          nextFace = nextForwardFace(face, neighborFaces);
          break;
        case DIRECTION_LEFT:
          nextFace = nextLeftFace(face, neighborFaces);
          break;
        case DIRECTION_BACK:
          nextFace = nextBackFace(face, neighborFaces);
          break;        
      }

      return nextFace;      
    }
    
    private HE_Face nextRightFace(HE_Face face, List<HE_Face> neighborFaces) {
      HE_Face nextFace = null;
      double maxX = face.getFaceCenter().xd();
      
      for(int i = 0; i < neighborFaces.size(); i++) {
        HE_Face currFace = neighborFaces.get(i); 
        if (currFace.getFaceCenter().xd() >  maxX && currFace.getLabel() == -1) {
          maxX = currFace.getFaceCenter().xd();
          nextFace = currFace;
        }
      }

      return nextFace;
    }
   
    private HE_Face nextForwardFace(HE_Face face, List<HE_Face> neighborFaces) {
      HE_Face nextFace = null;
      double maxZ = face.getFaceCenter().zd();
      
      for(int i = 0; i < neighborFaces.size(); i++) {
        HE_Face currFace = neighborFaces.get(i); 
        if (currFace.getLabel() == -1 && currFace.getFaceCenter().zd() >  maxZ) {
          maxZ = currFace.getFaceCenter().zd();
          nextFace = currFace;
        }        
      }

      return nextFace;
    }
   
    private HE_Face nextLeftFace(HE_Face face, List<HE_Face> neighborFaces) {
      HE_Face nextFace = null;
      double minX = face.getFaceCenter().xd();
      
      for(int i = 0; i < neighborFaces.size(); i++) {
        HE_Face currFace = neighborFaces.get(i); 
        if (currFace.getLabel() == -1 && currFace.getFaceCenter().xd() <  minX) {
          minX = currFace.getFaceCenter().xd();
          nextFace = currFace;
        }        
      }

      return nextFace;
    }
    
    private HE_Face nextBackFace(HE_Face face, List<HE_Face> neighborFaces) {
      HE_Face nextFace = null;
      double minZ = face.getFaceCenter().zd();
      
      for(int i = 0; i < neighborFaces.size(); i++) {
        HE_Face currFace = neighborFaces.get(i); 
        if (currFace.getLabel() == -1 && currFace.getFaceCenter().zd() <  minZ) {
          minZ = currFace.getFaceCenter().zd();
          nextFace = currFace;
        }        
      }

      return nextFace;
    } 
    
    private int nextDirection(int direction) {
      return (direction + 1) % 4;  
    }
    
    private HE_Face getFirstFace() {
      WB_Point farLeft = new WB_Point(0, -1000, -1000);
      HE_Vertex firstVertex = geodome.getClosestVertex(farLeft, this.vertexTree);
      HE_Face firstFace = null;
      float minX = 1000;
      println("FirstVertex: " + firstVertex);
      
      List<HE_Face> faces = firstVertex.getFaceStar();    
      println("Num star faces: " + faces.size());  
      for(int i = 0; i < faces.size(); i++) {
        WB_Point faceCenter = faces.get(i).getFaceCenter();        
        
        if (faceCenter.xf() < minX) {
          minX = faceCenter.xf();
          firstFace = faces.get(i);
        }        
      }

      return firstFace;      
    }
    
    private void plotLightsOnDome() {          
      for (int i = 0; i < lightStringFaceLists.size(); i++) {
        List<Integer> faceList = lightStringFaceLists.get(i);
                
        for(int j = 0; j < faceList.size(); j++) {
          int index = faceList.get(j);   
          plotLightsOnFace(faces.get(index));
        }
      }
    }
    
    private void plotLightsOnFace(LEDomeFace face) {
      ArrayList<LXPoint> points = new ArrayList<LXPoint>();
      ArrayList<LEDomeEdge> faceEdges = new ArrayList<LEDomeEdge>();
            
      HE_Face he_face = face.he_face;
      WB_Point faceCenter = he_face.getFaceCenter();          
      HE_Vertex isocVertex = findIsocVertex(he_face);
      HE_Vertex currVertex = isocVertex;
      WB_Transform moveTowardCenter = new WB_Transform();
      HE_Halfedge currHalfedge = isocVertex.getHalfedge(he_face);
      
      LEDomeEdge currDomeEdge = null;
      LEDomeEdge prevDomeEdge = null;      
      LXPoint lx_point;
                           
      do {             
        // Create LEDomeEdge model for the first edge.   
        currHalfedge.setLabel(this.edges.size());
        currDomeEdge = new LEDomeEdge(face, currHalfedge);
        faceEdges.add(currDomeEdge);
        this.edges.add(currDomeEdge);

        // Create vertex point by translating toward the center of the face from the vertex.
        moveTowardCenter.clear();
        moveTowardCenter.addTranslate(LIGHT_OFFSET_PROP, new WB_Vector(currVertex.getPoint(), faceCenter));
        WB_Point vertexPoint = currVertex.getPoint().apply(moveTowardCenter);
        lx_point = new LXPoint(vertexPoint.xf(), vertexPoint.yf(), vertexPoint.zf());

        // Add point to model and to points array.
        points.add(lx_point);
        addPoint(lx_point);

        if (LIGHT_DIRECTION == COUNTER_CLOCKWISE) {
          currHalfedge = currHalfedge.getNextInFace().getNextInFace();
        }

        // Add point to current edge
        currDomeEdge.addPoint(lx_point);
        if (prevDomeEdge != null) { // Also add point to previous edge if not null.
          prevDomeEdge.addPoint(lx_point);
        }

        // Create edge point by translating toward the center of the face.
        moveTowardCenter.clear();
        moveTowardCenter.addTranslate(LIGHT_OFFSET_PROP, new WB_Vector(currHalfedge.getEdgeCenter(), faceCenter));
        WB_Point edgeCenterPoint = currHalfedge.getEdgeCenter().apply(moveTowardCenter);
        lx_point = new LXPoint(edgeCenterPoint.xf(), edgeCenterPoint.yf(), edgeCenterPoint.zf());

        // Add point to model and to points array
        points.add(lx_point);
        addPoint(lx_point);        

        // Add point to current edge and cache for next iteration.
        currDomeEdge.addPoint(lx_point);
        prevDomeEdge = currDomeEdge;

        // Get next halfedge.
        // It seems going backwards gives us the direct we want (clockwise)
        if (LIGHT_DIRECTION == CLOCKWISE) {
          currHalfedge = currHalfedge.getPrevInFace().getPrevInFace();
        } 
        
        currVertex = currHalfedge.getVertex();
      } while(currVertex != isocVertex);

      // Add very first vertex point to final edge.
      prevDomeEdge.addPoint(points.get(0));      
        
      // Set points and edeges on the face.
      face.setPoints(points);
      face.setEdges(faceEdges);
    }

    private HE_Vertex findIsocVertex(HE_Face face) {
      List<HE_Vertex> vertices = face.getFaceVertices();
      HE_Vertex currVertex = vertices.get(0);
      HE_Vertex otherVertex;
      HE_Vertex isocVertex = null;
      WB_Point currPoint;
      WB_Point otherPoint;
      float dist1;
      float dist2;
      float distanceDiff;
      float minDistanceDiff = DOME_RADIUS;

      for(int i = 0; i < vertices.size(); i++) {       
        currVertex = vertices.get(i);
        currPoint = currVertex.getPoint();        
        dist1 = dist2 = 0.0f;
        
        for (int j = 0; j < vertices.size(); j++) {         
          if(i == j) { continue; }
          
          otherVertex = vertices.get(j);
          otherPoint = otherVertex.getPoint();
          if(dist1 == 0.0f) {
            dist1 = dist(currPoint.xf(), currPoint.yf(), currPoint.zf(), otherPoint.xf(), otherPoint.yf(), otherPoint.zf());
          } else {
            dist2 = dist(currPoint.xf(), currPoint.yf(), currPoint.zf(), otherPoint.xf(), otherPoint.yf(), otherPoint.zf());
          }            
        }

        distanceDiff = abs(dist1 - dist2);
        if (minDistanceDiff > distanceDiff) {
          minDistanceDiff = distanceDiff;          
          isocVertex = currVertex;
          
          // Can break if the distances are exactly the same.
          if (distanceDiff == 0.0f) { break; }
        }
      }

      return isocVertex;
    }
    
    public void outputDebugInfo() {
      HashMap<Integer, Integer> sizeCounts = new HashMap<Integer, Integer>();      
      sizeCounts.put(12, 0);
      sizeCounts.put(24, 0);
      sizeCounts.put(36, 0);      
      
      for(int i = 0; i < this.lightStringFaceLists.size(); i++) {
        List<Integer> faceList = this.lightStringFaceLists.get(i);
        
        for(int j = 0; j < faceList.size() - 1; j++) {
          int currentFaceIndex = faceList.get(j);
          int nextFaceIndex = faceList.get(j + 1);
          LEDomeFace currFace = faces.get(currentFaceIndex);
          LEDomeFace nextFace = faces.get(nextFaceIndex);
          LXPoint currFacePoint = currFace.points.get(5);
          LXPoint nextFacePoint = nextFace.points.get(0);
          float connectionDistance = dist(currFacePoint.x, currFacePoint.y, currFacePoint.z, nextFacePoint.x, nextFacePoint.y, nextFacePoint.z);
          println("Face " + currentFaceIndex + " -> Face " + nextFaceIndex + ": " + connectionDistance);          
                    
          if (connectionDistance < 12.0f) {
            sizeCounts.put(12, sizeCounts.get(12) + 1); 
          } else if(connectionDistance < 24.0f) {
            sizeCounts.put(24, sizeCounts.get(24) + 1);
          } else if(connectionDistance < 36.0f) {
            sizeCounts.put(36, sizeCounts.get(36) + 1);
          }
        }
      }
      
      for(Integer size : sizeCounts.keySet()) {
        println("Num under " + size + ": " + sizeCounts.get(size));
      }
    }
  }
}

static class LEDomeOutputManager {
  private P2LX lx;
  private boolean ndb_output_enabled;
  private LXDatagramOutput ndb_output;

  public LEDomeOutputManager(P2LX lx) {
    this.lx = lx;
    this.ndb_output_enabled = false;
  }

  public void toggleNDBOutput() {
    this.toggleNDBOutput(!this.ndb_output_enabled);
  }

  public void toggleNDBOutput(boolean enable) {
    if (enable) {
      this.addLXOutputForNDB();
    } else {
      this.removeLXOutputForNDB();
    }

    this.ndb_output_enabled = enable;
  }

  private void addLXOutputForNDB() {
    int[] points = new int[NUM_CONNECTED_LIGHTS];
    for (int i = 0; i < points.length; ++i) {
      points[i] = i;
    }

    try {
      this.ndb_output = new LXDatagramOutput(this.lx);
      DDPDatagram datagram = (DDPDatagram)new DDPDatagram(points).setAddress(NDB_IP_ADDRESS); // whatever the IP is
      this.ndb_output.addDatagram(datagram);
      this.lx.addOutput(this.ndb_output);
    } catch (Exception x) {
      x.printStackTrace();
    }
  }

  private void removeLXOutputForNDB() {
    if (this.ndb_output != null) {
      this.lx.removeOutput(this.ndb_output);
    }
  }
}
/**
 * The LEDomeFace class represents a face on the LEDome.
 * Use xf(), yf(), and zf() to get the coordinates of the center of the face.
 *
 * Furthermore:
 * It knows if it has any lights on it at all (LEDomeFace#hasLights())
 * It knows what which lights are on it's face (LEDomeFace#points)
 * It knows which faces are nearby (LEDomeFace#neighbors)
 * It knows the 3 faces in which it shares an edge (LEDomeFace#next_door_neighbors)
 * It also has a reference to the face object from the 3d mesh model (LEDomeFace#he_face)
 */
public static class LEDomeFace {
  public HE_Face he_face;
  public List<LXPoint> points;
  public List<LEDomeEdge> edges;
  private List<Integer> neighbors;
  private List<Integer> next_door_neighbors;

  public LEDomeFace(HE_Face face) {
    he_face = face;    
  }

  public LEDomeFace(HE_Face face, List<LXPoint> lxPoints) {
    he_face = face;
    points = lxPoints;    
  }
  
  public float xf() {
    return he_face.getFaceCenter().xf();  
  }
  
  public float yf() {
    return he_face.getFaceCenter().yf();  
  }
  
  public float zf() {
    return he_face.getFaceCenter().zf();  
  }
  
  public double xd() {
    return he_face.getFaceCenter().xd();  
  }
  
  public double yd() {
    return he_face.getFaceCenter().yd();  
  }
  
  public double zd() {
    return he_face.getFaceCenter().zd();  
  }

  public void setPoints(List<LXPoint> lxPoints) {
    this.points = lxPoints;    
  }
  
  public void setEdges(List<LEDomeEdge> edges) {
    this.edges = edges;  
  }
  
  public List<Integer> getNeighbors() {
    if (this.neighbors == null) {      
      this.neighbors = new ArrayList<Integer>();
      for(HE_Vertex he_vertex : this.he_face.getFaceVertices()) {
        for(HE_Face he_neighbor : he_vertex.getFaceStar()) {
          if (he_neighbor.getLabel() == this.he_face.getLabel()) {
            continue;  
          }
          
          if (!this.neighbors.contains(he_neighbor.getLabel())) {
            this.neighbors.add(he_neighbor.getLabel());  
          }
        }
      }
    }
    
    return this.neighbors;
  }    
  
  public List<Integer> getNextDoorNeighbors() {
    if (this.next_door_neighbors == null) {
      this.next_door_neighbors = new ArrayList<Integer>();      
      for(HE_Face he_neighbor : this.he_face.getNeighborFaces()) {                
        if (!this.next_door_neighbors.contains(he_neighbor.getLabel())) {
          this.next_door_neighbors.add(he_neighbor.getLabel());  
        }
      }
    }
    
    return this.next_door_neighbors;
  }
  
  public boolean hasLights() {
    return this.points != null && this.points.size() > 0;    
  }
  
  public boolean onFace(LXPoint point) {
    return this.points != null && this.points.contains(point);
  }
}

public static class LEDomeEdge {  
  public HE_Halfedge he_halfedge;
  public LEDomeFace ledome_face;
  public List<LXPoint> points;  
  
  public LEDomeEdge(LEDomeFace face, HE_Halfedge edge) {
    setFace(face);
    setHalfedge(edge);        
  }
  
  public LEDomeEdge(LEDomeFace face, HE_Halfedge edge, List<LXPoint> points) {
    setFace(face);
    setHalfedge(edge);
    setPoints(points);
  }
  
  public void setFace(LEDomeFace face) {
    this.ledome_face = face;
  }
  
  public void setHalfedge(HE_Halfedge edge) {    
    this.he_halfedge = edge;
  }
  
  public void setPoints(List<LXPoint> points) {
    this.points = points;
  }
  
  public void addPoint(LXPoint point) {
    if(this.points == null) {
      this.points = new ArrayList<LXPoint>();
    }
    
    points.add(point);
  }
  
  public LXPoint closestPoint(float x, float y, float z) {
    float min_dist = 1000 * FEET;
    LXPoint retPoint = this.points.get(0);
    
    for(LXPoint p : this.points) {
      float curr_dist = dist(p.x, p.y, p.z, x, y, z);
      
      if(curr_dist < min_dist) {
        min_dist = curr_dist;
        retPoint = p;
      }
    }
    
    return retPoint;
  }
  
  public LXPoint closestVertexPoint(float x, float y, float z) {
    float min_dist = 1000 * FEET;
    LXPoint retPoint = this.points.get(0);    
    LXPoint[] vertexPoints = new LXPoint[] { this.points.get(0), this.points.get(2) };  

    for(LXPoint p : vertexPoints) {
      float curr_dist = dist(p.x, p.y, p.z, x, y, z);
      
      if(curr_dist < min_dist) {
        min_dist = curr_dist;
        retPoint = p;
      }
    }
    
    return retPoint;
  }
  
  public float xf() {
    return he_halfedge.getEdgeCenter().xf();  
  }
  
  public float yf() {
    return he_halfedge.getEdgeCenter().yf();  
  }
  
  public float zf() {
    return he_halfedge.getEdgeCenter().zf();  
  }
  
  public double xd() {
    return he_halfedge.getEdgeCenter().xd();  
  }
  
  public double yd() {
    return he_halfedge.getEdgeCenter().yd();  
  }
  
  public double zd() {
    return he_halfedge.getEdgeCenter().zd();  
  }
   
  public boolean hasLights() {
   return this.points != null && this.points.size() > 0;    
  }
  
  public boolean onEdge(LXPoint point) {
    return this.points != null && this.points.contains(point);
  }
}
class Spiral extends LXPattern {
  private final int numFaces = ((LEDome)model).faces.size();
  private final BasicParameter tail = new BasicParameter("Tail", 4, 1, numFaces / 3);
  private final BasicParameter offset = new BasicParameter("Offset", 15, 1, numFaces / 2);
  private final BasicParameter faceVariation = new BasicParameter("Face", 0, 0, 2);
  private final BasicParameter numTrails = new BasicParameter("Trails", 4, 1, 4);
  private final BasicParameter solidFaces = new BasicParameter("Solid", 0, 0, 1);

  public Spiral(LX lx) {
    super(lx); 
    addParameter(tail);
    addParameter(offset);
    addParameter(faceVariation);
    addParameter(numTrails);
    addParameter(solidFaces);
    addLayer(new SpiralLayer(lx));    
  }

  public void run(double deltaMs) {
    // The layers run automatically
  }

  private class SpiralLayer extends LXLayer {
    private final TriangleLFO currIndex = new TriangleLFO(0, numFaces, numFaces * 100);
    private final TriangleLFO minBright = new TriangleLFO(10, 25, numFaces * 25);
    private HashMap<Integer, Float> trailToHue = new HashMap();

    private SpiralLayer(LX lx) {
      super(lx);
      addModulator(currIndex).start();
      addModulator(minBright).start();
    }

    public void run(double deltaMs) {  
      int index = (int) currIndex.getValuef();

      for(int i = 0; i < numFaces; i++) {
        LEDomeFace face = ((LEDome)model).faces.get(i);
        if(!face.hasLights()) {
          continue;  
        }

        int tailValue = (int) tail.getValue();
        int offsetValue = (int) offset.getValue();
        int numTrailsValue = Math.round(numTrails.getValuef());
        boolean solidFacesValue = Math.round(solidFaces.getValuef()) != 0;
        int currTrail = 0;

        float saturation = 100;
        float brightness = 0;
        float hue = 0;
        boolean active = false;

        for (; currTrail < numTrailsValue; currTrail++) {
          if (abs(i - index + currTrail * (offsetValue + tailValue)) < tailValue) {
            active = true;
            break;
          }
        }

        // Update LFO minimum so we always see both trails
        currIndex.setStartValue((numTrailsValue - 1) * (offsetValue + tailValue));

        for (LEDomeEdge edge : face.edges) {
          brightness = minBright.getValuef();

          if (active) {
            // Step transition brightness
            brightness = 100 - face.edges.indexOf(edge) * faceVariation.getValuef() * brightness;
          }

          for (LXPoint p : edge.points) {
            hue = getHue(p, active, solidFacesValue, currTrail);
            colors[p.index] = LX.hsb(hue, saturation, brightness);    
          }
        }
      }
    }

    private float getHue(LXPoint p, boolean active, boolean isSolid, int currTrail) {
        float hue = 0;

        // Ty BK!
        float pixelAngle = (p.ztheta * (180.0f/PI));
        hue = pixelAngle % 360;

        if (!active) {
          return 360 - hue;
        }

        if (isSolid) {
          // avoid black
          if (hue > 210 & hue < 240) {
            hue = 210;
          } else if (hue >= 240 && hue < 270) {
            hue = 270;
          }

          if (trailToHue.containsKey(currTrail)) {
            hue = trailToHue.get(currTrail);
          } else {
            trailToHue.put(currTrail, hue);
          }
        }

        return hue;
    }
  } 
}
/**
 * This file has a bunch of example patterns, each illustrating the key
 * concepts and tools of the LX framework.
 */
 
class HueTestPattern extends LXPattern {
  private final BasicParameter colorChangeSpeed = new BasicParameter("SPD",  5000, 0, 10000);
  private final SinLFO whatColor = new SinLFO(0, 360, colorChangeSpeed);
  
  public HueTestPattern(LX lx) {
    super(lx);
    addParameter(colorChangeSpeed);
    addModulator(whatColor).trigger();
  }

  public void run(double deltaMs){
    for (LXPoint p : model.points) {
      float h = whatColor.getValuef();
      int s = 100;
      int b = 70;
      colors[p.index] = LX.hsb(h,s,b);
    }
  }
}


class FaceIteratorTest extends LXPattern {
  private final SawLFO currIndex = new SawLFO(0, ((LEDome)model).faces.size(), ((LEDome)model).faces.size() * 300);
  public FaceIteratorTest(LX lx) {
    super(lx);     
    
    addModulator(currIndex).start();     
  }
  
  public void run(double deltaMs) {
    int index = (int) currIndex.getValuef();
    
    for(int i = 0; i < ((LEDome)model).faces.size(); i++) {
      LEDomeFace face = ((LEDome)model).faces.get(i);
      if(!face.hasLights()) {
        continue;  
      }
      
      float bv = (i == index) ? 100.0f : 0.0f;
     
      for(LXPoint p : face.points) {
        colors[p.index] = LX.hsb(120, 90, bv);    
      }
    }
  }
}

class EdgeIteratorTest extends LXPattern {
  private final SawLFO currIndex = new SawLFO(0, ((LEDome)model).edges.size(), ((LEDome)model).edges.size() * 200);
  
  public EdgeIteratorTest(LX lx) {
    super(lx);
    
    addModulator(currIndex).start();     
  }
  
  public void run(double deltaMs) {
    int index = (int) currIndex.getValuef();
    LEDomeEdge edge = ((LEDome)model).edges.get(index);
    
    for(LXPoint p : model.points) {
      float bv = edge.onEdge(p) ? 100.0f : 0.0f;
      colors[p.index] = LX.hsb(120, 90, bv);  
    }
  }
}
 
class LayerDemoPattern extends LXPattern {  
  private final BasicParameter colorSpread = new BasicParameter("Clr", 0.5f, 0, 3);
  private final BasicParameter stars = new BasicParameter("Stars", 100, 0, 100);
  
  public LayerDemoPattern(LX lx) {
    super(lx);        
    addParameter(colorSpread);
    addParameter(stars);
    addLayer(new CircleLayer(lx));
    addLayer(new RodLayer(lx));
    for (int i = 0; i < 200; ++i) {
      addLayer(new StarLayer(lx));
    }
  }
  
  public void run(double deltaMs) {
    // The layers run automatically
  }
  
  private class CircleLayer extends LXLayer {
    
    private final SinLFO xPeriod = new SinLFO(3400, 7900, 11000); 
    private final SinLFO brightnessX = new SinLFO(model.xMin, model.xMax, xPeriod);
  
    private CircleLayer(LX lx) {
      super(lx);
      addModulator(xPeriod).start();
      addModulator(brightnessX).start();
    }
    
    public void run(double deltaMs) {
      // The layers run automatically
      float falloff = 100 / (4*FEET);      
      for (LXPoint p : model.points) {
        float yWave = model.yRange/2 * sin(p.x / model.xRange * PI); 
        float distanceFromCenter = dist(p.x, p.y, model.cx, model.cy);
        float distanceFromBrightness = dist(p.x, abs(p.y - model.cy), brightnessX.getValuef(), yWave);
        colors[p.index] = LXColor.hsb(
          lx.getBaseHuef() + colorSpread.getValuef() * distanceFromCenter,
          100,
          max(0, 100 - falloff*distanceFromBrightness)
        );
      }           
    }
  }
  
  private class RodLayer extends LXLayer {

    private final SinLFO zPeriod = new SinLFO(2000, 5000, 9000);
    private final SinLFO zPos = new SinLFO(model.zMin, model.zMax, zPeriod);
    
    private RodLayer(LX lx) {
      super(lx);
      addModulator(zPeriod).start();
      addModulator(zPos).start();
    }
    
    public void run(double deltaMs) {
      for (LXPoint p : model.points) {
        float b = 100 - dist(p.x, p.y, model.cx, model.cy) - abs(p.z - zPos.getValuef());
        if (b > 0) {
          addColor(p.index, LXColor.hsb(
            lx.getBaseHuef() + p.z,
            100,
            b
          ));
        }
      }
    }
  }
  
  private class StarLayer extends LXLayer {
    
    private final TriangleLFO maxBright = new TriangleLFO(0, stars, random(2000, 8000));
    private final SinLFO brightness = new SinLFO(-1, maxBright, random(3000, 9000)); 
    
    private int index = 0;
    
    private StarLayer(LX lx) { 
      super(lx);
      addModulator(maxBright).start();
      addModulator(brightness).start();
      pickStar();
    }
    
    private void pickStar() {
      index = (int) random(0, model.size-1);
    }
    
    public void run(double deltaMs) {
      if (brightness.getValuef() <= 0) {
        pickStar();
      } else {
        addColor(index, LXColor.hsb(lx.getBaseHuef(), 50, brightness.getValuef()));
      }
    }
  }
}
/**
 *     DOUBLE BLACK DIAMOND        DOUBLE BLACK DIAMOND
 *
 *         //\\   //\\                 //\\   //\\  
 *        ///\\\ ///\\\               ///\\\ ///\\\
 *        \\\/// \\\///               \\\/// \\\///
 *         \\//   \\//                 \\//   \\//
 *
 *        EXPERTS ONLY!!              EXPERTS ONLY!!
 *
 * This file contains code to draws the dome model and set up 
 * the UI for the simulation. Please do not change this file
 * unless you know what you are doing. 
 */
 
/**
 * Here's a simple extension of a camera component. This will be
 * rendered inside the camera view context. We just override the
 * onDraw method and invoke Processing drawing methods directly.
 */
class UIDome extends UI3dComponent {
  private boolean LABEL_FACES = false; 
  
  protected void onDraw(UI ui, PGraphics pg) {
    HE_Mesh geodome = model.getLEDomeMesh();        
    
    stroke(5);
    render.drawEdges(geodome);
    
    if (LABEL_FACES) {
      stroke(1);
      labelFaces(geodome);
    }    
  }
  
  private void labelFaces(HE_Mesh geodome) {      
    int numFaces = geodome.getNumberOfFaces();
    HE_Face currentFace;
    WB_Point faceCenter;  
    
    for(int i = 0; i < numFaces; i++) {    
      currentFace = geodome.getFaceByIndex(i);
      faceCenter = currentFace.getFaceCenter();
      if (currentFace.getLabel() != -1) {
        pushMatrix();
        text(currentFace.getLabel(), faceCenter.xf(), faceCenter.yf(), faceCenter.zf());
        popMatrix();
      }
    }      
  }
}

class UIEngineControl extends UIWindow {
  
  final UIKnob fpsKnob;
  
  UIEngineControl(UI ui, float x, float y) {
    super(ui, "ENGINE", x, y, UIChannelControl.WIDTH, 96);
        
    y = UIWindow.TITLE_LABEL_HEIGHT;
    new UIButton(4, y, width-8, 20) {
      protected void onToggle(boolean enabled) {
        lx.engine.setThreaded(enabled);
        fpsKnob.setEnabled(enabled);
      }
    }
    .setActiveLabel("Multi-Threaded")
    .setInactiveLabel("Single-Threaded")
    .addToContainer(this);
    
    y += 24;
    fpsKnob = new UIKnob(4, y);    
    fpsKnob
    .setParameter(lx.engine.framesPerSecond)
    .setEnabled(lx.engine.isThreaded())
    .addToContainer(this);
  }
}

class LEDomeNDBOutputControl extends UIWindow { 
  LEDomeNDBOutputControl(UI ui, float x, float y) {
    super(ui, "NDB Output", x, y, UIChannelControl.WIDTH, 50);    
    
    y = UIWindow.TITLE_LABEL_HEIGHT;
    
    new UIButton(4, y, width-8, 20) {
      protected void onToggle(boolean enabled) {
        println("Toggle NDB output: " + enabled);
        output_manager.toggleNDBOutput(enabled);
      }  
    }
    .setInactiveLabel("Output to NDB")
    .setActiveLabel("Disconnect NDB")    
    .addToContainer(this);
  }
}
/**
 *     DOUBLE BLACK DIAMOND        DOUBLE BLACK DIAMOND
 *
 *         //\\   //\\                 //\\   //\\  
 *        ///\\\ ///\\\               ///\\\ ///\\\
 *        \\\/// \\\///               \\\/// \\\///
 *         \\//   \\//                 \\//   \\//
 *
 *        EXPERTS ONLY!!              EXPERTS ONLY!!
 *
 * This implements the standard `setup` and `draw` methods of a 
 * Processing sketch. It instantiates LEDome model and the sets
 * up the DDP output to the NDB. This file should only be changed 
 * by people who know what their doing.
 */
 


 
Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
final int VIEWPORT_WIDTH = (int)screenSize.getWidth();;
final int VIEWPORT_HEIGHT = (int)screenSize.getHeight();


LEDome model;
P2LX lx;
WB_Render render;
LEDomeOutputManager output_manager;

/*
 * Setup methods. Sets stuff up.
 */
public void setup() {
  size(VIEWPORT_WIDTH, VIEWPORT_HEIGHT, OPENGL);
  frame.setResizable(true);
  noSmooth();
  textSize(6);
  
  // Create LEDome instance
  model = new LEDome();  
  // Create the P2LX engine
  lx = new P2LX(this, model);    
  // Create the NDB output manager
  output_manager = new LEDomeOutputManager(lx);
  
  setupPatterns();  
  setupEffects();
  setupUI();  
  
  render = new WB_Render(this);  
}

public void setupPatterns() {
  lx.setPatterns(patterns(lx));
}

public void setupEffects() {
  lx.addEffects(effects(lx));  
}

public void setupUI() {
  lx.ui.addLayer(
    // A camera layer makes an OpenGL layer that we can easily 
    // pivot around with the mouse
    new UI3dContext(lx.ui) {
      protected void beforeDraw(UI ui, PGraphics pg) {
        // Let's add lighting and depth-testing to our 3-D simulation
        pointLight(0, 0, 40, model.cx, model.cy, -20*FEET);
        pointLight(0, 0, 50, model.cx, model.yMax + 10*FEET, model.cz);
        pointLight(0, 0, 20, model.cx, model.yMin - 10*FEET, model.cz);
        hint(ENABLE_DEPTH_TEST);
      }
      protected void afterDraw(UI ui, PGraphics pg) {
        // Turn off the lights and kill depth testing before the 2D layers
        noLights();
        hint(DISABLE_DEPTH_TEST);
      } 
    }
  
    // Let's look at the center of our model
    .setCenter(model.cx, model.cy, model.cz)
  
    // Let's position our eye some distance away
    .setRadius(22*FEET)
    
    // And look at it from a bit of an angle
    .setTheta(PI/24)
    .setPhi(PI/24)
    
    .setRotationVelocity(12*PI)
    .setRotationAcceleration(3*PI)
    
    // Let's add a point cloud of our animation points
    .addComponent(new UIPointCloud(lx, model).setPointSize(3))
    
    .addComponent(new UIDome())
  );
  
  // A basic built-in 2-D control for a channel
  lx.ui.addLayer(new UIChannelControl(lx.ui, lx.engine.getDefaultChannel(), 4, 4));  
  lx.ui.addLayer(new LEDomeNDBOutputControl(lx.ui, 4, 326));
  lx.ui.addLayer(new UIEffectsControl(lx.ui, lx, width-144, 4));
}

public void draw() {
  background(0xff292929);  
}

public void mousePressed() {
  println("mouseX:" + mouseX + ", mouseY: " + mouseY);  
}
  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "dome" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
